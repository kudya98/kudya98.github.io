{"version":3,"sources":["../node_modules/monaco-editor/esm/vs/language/json/workerManager.js","../node_modules/monaco-editor/esm/vs/language/json/_deps/vscode-languageserver-types/main.js","../node_modules/monaco-editor/esm/vs/language/json/languageFeatures.js","../node_modules/monaco-editor/esm/vs/language/json/_deps/jsonc-parser/impl/scanner.js","../node_modules/monaco-editor/esm/vs/language/json/_deps/jsonc-parser/impl/format.js","../node_modules/monaco-editor/esm/vs/language/json/_deps/jsonc-parser/impl/parser.js","../node_modules/monaco-editor/esm/vs/language/json/_deps/jsonc-parser/impl/edit.js","../node_modules/monaco-editor/esm/vs/language/json/_deps/jsonc-parser/main.js","../node_modules/monaco-editor/esm/vs/language/json/tokenization.js","../node_modules/monaco-editor/esm/vs/language/json/jsonMode.js"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACa;;AAEb,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,oBAAoB,uBAAuB;AAC3C;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA,CAAC;;;;ACjGD;AACA;AACA;AACA;AACa;AACb;AACA;AACA;AACA;;AAEO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,oEAAoE;AACrE;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,uBAAuB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,4CAA4C;;AAEtC;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,gCAAgC;;AAE1B;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,gCAAgC;;AAE1B;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,gCAAgC;;AAE1B;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA,CAAC,sCAAsC;;AAEvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;AACD;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAE0B;AAC3B;AACA;AACA;AACA;;AAEO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,0EAA0E;AAC3E;AACA;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC,gCAAgC;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC,gCAAgC;;AAE1B;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC,wCAAwC;;AAElC;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wBAAwB;AAC9D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,oCAAoC;;AAE9B;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;;AAEA,oBAAoB,uBAAuB;AAC3C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;;AAE1B;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAEyB;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,8CAA8C;;AAExC;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAEuB;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,oCAAoC;;AAE9B;AACA;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA,wCAAwC,QAAQ;AAChD;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;;;AAGO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC,wDAAwD;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC,gBAAgB,G;;ACv1DjB;AACA;AACA;AACA;AACa;;AAEqD;AAClE;AACA,IAAI,sBAAK,gBAAgB;;AAEzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA,CAAC;;AAE6B;;AAE9B;AACA;AACA,SAAS,kBAAqB;AAC9B;;AAEA,SAAS,kBAAqB;AAC9B;;AAEA,SAAS,kBAAqB;AAC9B;;AAEA,SAAS,kBAAqB;AAC9B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,sBAAK;AAClB;;AAEA;AACA;;AAEA;AACA,SAAS,kBAAqB;AAC9B;;AAEA,SAAS,kBAAqB;AAC9B;;AAEA,SAAS,kBAAqB;AAC9B;;AAEA,SAAS,kBAAqB;AAC9B;;AAEA,SAAS,kBAAqB;AAC9B;;AAEA,SAAS,kBAAqB;AAC9B;;AAEA,SAAS,kBAAqB;AAC9B;;AAEA,SAAS,kBAAqB;AAC9B;;AAEA,SAAS,kBAAqB;AAC9B;;AAEA,SAAS,kBAAqB;AAC9B;;AAEA,SAAS,kBAAqB;AAC9B;;AAEA,SAAS,kBAAqB;AAC9B;;AAEA,SAAS,kBAAqB;AAC9B;;AAEA,SAAS,kBAAqB;AAC9B;;AAEA,SAAS,kBAAqB;AAC9B;;AAEA,SAAS,kBAAqB;AAC9B;;AAEA,SAAS,kBAAqB;AAC9B;;AAEA,SAAS,kBAAqB;AAC9B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,kBAAqB;;AAElC;AACA,aAAa,kBAAqB;;AAElC;AACA,aAAa,kBAAqB;;AAElC;AACA,aAAa,kBAAqB;;AAElC;AACA,aAAa,kBAAqB;;AAElC;AACA,aAAa,kBAAqB;;AAElC;AACA,aAAa,kBAAqB;;AAElC;AACA,aAAa,kBAAqB;;AAElC;AACA,aAAa,kBAAqB;;AAElC;AACA,aAAa,kBAAqB;;AAElC;AACA,aAAa,kBAAqB;;AAElC;AACA,aAAa,kBAAqB;;AAElC;AACA,aAAa,kBAAqB;;AAElC;AACA,aAAa,kBAAqB;;AAElC;AACA,aAAa,kBAAqB;;AAElC;AACA,aAAa,kBAAqB;;AAElC;AACA,aAAa,kBAAqB;;AAElC;AACA,aAAa,kBAAqB;AAClC;;AAEA,SAAS,kBAAqB;AAC9B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,IAAI,kCAAiB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,0BAA0B,sBAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC,gBAAmB;AAC1D;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,CAAC;;AAE4B;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,CAAC;;AAEuB;;AAExB;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;;AAEA;AACA,SAAS,UAAa;AACtB;;AAEA,SAAS,UAAa;AACtB;;AAEA,SAAS,UAAa;AACtB;;AAEA,SAAS,UAAa;AACtB;;AAEA,SAAS,UAAa;AACtB;;AAEA,SAAS,UAAa;AACtB;;AAEA,SAAS,UAAa;AACtB;;AAEA,SAAS,UAAa;AACtB;;AAEA,SAAS,UAAa;AACtB;;AAEA,SAAS,UAAa;AACtB;;AAEA,SAAS,UAAa;AACtB;;AAEA,SAAS,UAAa;AACtB;;AAEA,SAAS,UAAa;AACtB;;AAEA,SAAS,UAAa;AACtB;;AAEA,SAAS,UAAa;AACtB;;AAEA,SAAS,UAAa;AACtB;;AAEA,SAAS,UAAa;AACtB;;AAEA,SAAS,UAAa;AACtB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA,CAAC;;AAEgC;;AAEjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA,CAAC;;AAEyC;;AAE1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA,CAAC;;AAE8C;;AAE/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA,CAAC;;AAE+B;;AAEhC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA,CAAC;;AAE8B;;AAE/B;AACA;AACA,SAAS,gBAAmB;AAC5B;;AAEA,SAAS,gBAAmB;AAC5B;;AAEA,SAAS,gBAAmB;AAC5B;AACA;;AAEA;AACA,C;;AC1tBA;AACA;AACA;AACA;AACa;AACb;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;;;AAGX;AACA;AACA;AACA;AACA,qCAAqC;;AAErC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;;;AAGX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD;;AAEnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;;AAGT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,C;;AChsBA;AACA;AACA;AACA;AACa;;AAEgC;AACtC;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA,gBAAgB,aAAa;AAC7B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,WAAW;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA,C;;AC/SA;AACA;AACA;AACA;AACa;;AAEgC;AAC7C;;AAEA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;;;AAGO;AACP,oBAAoB;;AAEpB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,2CAA2C;AAChE;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;;AAEA,iCAAiC,oBAAoB;AACrD;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,0CAA0C,gBAAgB;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;;AAEA,0CAA0C,gBAAgB;AAC1D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,qDAAqD;AAC1E;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA,iBAAiB,aAAa;;AAE9B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe;;AAEf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA,eAAe;;AAEf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,C;;ACx8BA;AACA;AACA;AACA;AACa;;AAE+B;AACgB;AACrD;AACP;AACA;AACO;AACP;;AAEA;AACA;AACA,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA,aAAa,kBAAkB;;AAE/B;AACA;AACA,wBAAwB;AACxB,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,mBAAmB,kBAAkB;;AAErC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,sCAAsC;;AAEtC;AACA;;AAEA;AACA;AACA,yBAAyB,KAAK;AAC9B;AACA;;AAEA,oCAAoC,KAAK;AACzC;AACA;AACA;;AAEA,cAAc,MAAM;AACpB;AACA;AACA,GAAG,qBAAqB;;AAExB,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEO;AACP;AACA;AACO;AACP;AACA,C;;AC1OA;AACA;AACA;AACA;AACa;;AAEiC;AACP;AACM;AACF;AAC3C;AACA;AACA;AACA;;AAEO,IAAI,kBAAa,GAAG,aAAqB;AAChD;AACA;AACA;;AAEO,IAAI,gBAAW,GAAG,WAAkB;AAC3C;AACA;AACA;AACA;;AAEO,IAAI,UAAK,GAAG,KAAY;AAC/B;AACA;AACA;;AAEO,IAAI,cAAS,GAAG,SAAgB;AACvC;AACA;AACA;;AAEO,IAAI,uBAAkB,GAAG,kBAAyB;AACzD;AACA;AACA;;AAEO,IAAI,qBAAgB,GAAG,gBAAuB;AACrD;AACA;AACA;;AAEO,IAAI,gBAAW,GAAG,WAAkB;AAC3C;AACA;AACA;;AAEO,IAAI,iBAAY,GAAG,YAAmB;AAC7C;AACA;AACA;;AAEO,IAAI,UAAK,GAAG,KAAY;AAC/B;AACA;AACA;AACA;AACA;;AAEO,IAAI,kBAAa,GAAG,aAAoB;AACxC;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO,SAAS,WAAM;AACtB,SAAS,MAAgB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP,SAAS,WAAgB;AACzB;AACA;AACA;AACA;;AAEO;AACP,gCAAgC,QAAQ;AACxC,WAAW,SAAc;AACzB;;AAEA;AACA,C;;AClMA;AACA;AACA;AACA;AACa;;AAEwC;AAC9C;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;;AAGP;AACA;AACA,KAAK;AACL;;;AAGA;AACA;AACA;;AAEA,kDAAkD;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,C;;AC/NA;AAAA;AACA;AACA;AACA;AACa;;AAEsC;AACO;AACI;AACvD;AACP;AACA;AACA,mBAAmB,aAAa;AAChC;;AAEA;AACA;;AAEA,oBAAoB,uBAAuB;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6FAA6F,8BAA+C;AAC5I;;AAEA;AACA,kGAAkG,mCAAoD;AACtJ;;AAEA;AACA,qFAAqF,kCAAkC;AACvH;;AAEA;AACA,4EAA4E,YAA6B;AACzG;;AAEA;AACA,qFAAqF,qBAAsC;AAC3H;;AAEA;AACA,oEAAoE,yBAAyB;AAC7F;;AAEA;AACA,4EAA4E,oBAAqC;AACjH;;AAEA;AACA,mFAAmF,mBAAoC;AACvH;;AAEA;AACA,yBAAyB,kBAAmC;AAC5D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,IAAI;AAC1C;AACA;AACA;AACA,GAAG;AACH,gBAAgB,KAAK;AACrB;AACA,YAAY;AACZ,aAAa;AACb;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH,E","file":"static/js/10.bd538e86.chunk.js","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nvar STOP_WHEN_IDLE_FOR = 2 * 60 * 1000; // 2min\n\nvar WorkerManager =\n/** @class */\nfunction () {\n  function WorkerManager(defaults) {\n    var _this = this;\n\n    this._defaults = defaults;\n    this._worker = null;\n    this._idleCheckInterval = setInterval(function () {\n      return _this._checkIfIdle();\n    }, 30 * 1000);\n    this._lastUsedTime = 0;\n    this._configChangeListener = this._defaults.onDidChange(function () {\n      return _this._stopWorker();\n    });\n  }\n\n  WorkerManager.prototype._stopWorker = function () {\n    if (this._worker) {\n      this._worker.dispose();\n\n      this._worker = null;\n    }\n\n    this._client = null;\n  };\n\n  WorkerManager.prototype.dispose = function () {\n    clearInterval(this._idleCheckInterval);\n\n    this._configChangeListener.dispose();\n\n    this._stopWorker();\n  };\n\n  WorkerManager.prototype._checkIfIdle = function () {\n    if (!this._worker) {\n      return;\n    }\n\n    var timePassedSinceLastUsed = Date.now() - this._lastUsedTime;\n\n    if (timePassedSinceLastUsed > STOP_WHEN_IDLE_FOR) {\n      this._stopWorker();\n    }\n  };\n\n  WorkerManager.prototype._getClient = function () {\n    this._lastUsedTime = Date.now();\n\n    if (!this._client) {\n      this._worker = monaco.editor.createWebWorker({\n        // module that exports the create() method and returns a `JSONWorker` instance\n        moduleId: 'vs/language/json/jsonWorker',\n        label: this._defaults.languageId,\n        // passed in to the create() method\n        createData: {\n          languageSettings: this._defaults.diagnosticsOptions,\n          languageId: this._defaults.languageId,\n          enableSchemaRequest: this._defaults.diagnosticsOptions.enableSchemaRequest\n        }\n      });\n      this._client = this._worker.getProxy();\n    }\n\n    return this._client;\n  };\n\n  WorkerManager.prototype.getLanguageServiceWorker = function () {\n    var _this = this;\n\n    var resources = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      resources[_i] = arguments[_i];\n    }\n\n    var _client;\n\n    return this._getClient().then(function (client) {\n      _client = client;\n    }).then(function (_) {\n      return _this._worker.withSyncedResources(resources);\n    }).then(function (_) {\n      return _client;\n    });\n  };\n\n  return WorkerManager;\n}();\n\nexport { WorkerManager };","/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\n'use strict';\n/**\r\n * The Position namespace provides helper functions to work with\r\n * [Position](#Position) literals.\r\n */\n\nexport var Position;\n\n(function (Position) {\n  /**\r\n   * Creates a new Position literal from the given line and character.\r\n   * @param line The position's line.\r\n   * @param character The position's character.\r\n   */\n  function create(line, character) {\n    return {\n      line: line,\n      character: character\n    };\n  }\n\n  Position.create = create;\n  /**\r\n   * Checks whether the given liternal conforms to the [Position](#Position) interface.\r\n   */\n\n  function is(value) {\n    var candidate = value;\n    return Is.objectLiteral(candidate) && Is.number(candidate.line) && Is.number(candidate.character);\n  }\n\n  Position.is = is;\n})(Position || (Position = {}));\n/**\r\n * The Range namespace provides helper functions to work with\r\n * [Range](#Range) literals.\r\n */\n\n\nexport var Range;\n\n(function (Range) {\n  function create(one, two, three, four) {\n    if (Is.number(one) && Is.number(two) && Is.number(three) && Is.number(four)) {\n      return {\n        start: Position.create(one, two),\n        end: Position.create(three, four)\n      };\n    } else if (Position.is(one) && Position.is(two)) {\n      return {\n        start: one,\n        end: two\n      };\n    } else {\n      throw new Error(\"Range#create called with invalid arguments[\" + one + \", \" + two + \", \" + three + \", \" + four + \"]\");\n    }\n  }\n\n  Range.create = create;\n  /**\r\n   * Checks whether the given literal conforms to the [Range](#Range) interface.\r\n   */\n\n  function is(value) {\n    var candidate = value;\n    return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);\n  }\n\n  Range.is = is;\n})(Range || (Range = {}));\n/**\r\n * The Location namespace provides helper functions to work with\r\n * [Location](#Location) literals.\r\n */\n\n\nexport var Location;\n\n(function (Location) {\n  /**\r\n   * Creates a Location literal.\r\n   * @param uri The location's uri.\r\n   * @param range The location's range.\r\n   */\n  function create(uri, range) {\n    return {\n      uri: uri,\n      range: range\n    };\n  }\n\n  Location.create = create;\n  /**\r\n   * Checks whether the given literal conforms to the [Location](#Location) interface.\r\n   */\n\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\n  }\n\n  Location.is = is;\n})(Location || (Location = {}));\n/**\r\n * The LocationLink namespace provides helper functions to work with\r\n * [LocationLink](#LocationLink) literals.\r\n */\n\n\nexport var LocationLink;\n\n(function (LocationLink) {\n  /**\r\n   * Creates a LocationLink literal.\r\n   * @param targetUri The definition's uri.\r\n   * @param targetRange The full range of the definition.\r\n   * @param targetSelectionRange The span of the symbol definition at the target.\r\n   * @param originSelectionRange The span of the symbol being defined in the originating source file.\r\n   */\n  function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\n    return {\n      targetUri: targetUri,\n      targetRange: targetRange,\n      targetSelectionRange: targetSelectionRange,\n      originSelectionRange: originSelectionRange\n    };\n  }\n\n  LocationLink.create = create;\n  /**\r\n   * Checks whether the given literal conforms to the [LocationLink](#LocationLink) interface.\r\n   */\n\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && (Range.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange)) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\n  }\n\n  LocationLink.is = is;\n})(LocationLink || (LocationLink = {}));\n/**\r\n * The Color namespace provides helper functions to work with\r\n * [Color](#Color) literals.\r\n */\n\n\nexport var Color;\n\n(function (Color) {\n  /**\r\n   * Creates a new Color literal.\r\n   */\n  function create(red, green, blue, alpha) {\n    return {\n      red: red,\n      green: green,\n      blue: blue,\n      alpha: alpha\n    };\n  }\n\n  Color.create = create;\n  /**\r\n   * Checks whether the given literal conforms to the [Color](#Color) interface.\r\n   */\n\n  function is(value) {\n    var candidate = value;\n    return Is.number(candidate.red) && Is.number(candidate.green) && Is.number(candidate.blue) && Is.number(candidate.alpha);\n  }\n\n  Color.is = is;\n})(Color || (Color = {}));\n/**\r\n * The ColorInformation namespace provides helper functions to work with\r\n * [ColorInformation](#ColorInformation) literals.\r\n */\n\n\nexport var ColorInformation;\n\n(function (ColorInformation) {\n  /**\r\n   * Creates a new ColorInformation literal.\r\n   */\n  function create(range, color) {\n    return {\n      range: range,\n      color: color\n    };\n  }\n\n  ColorInformation.create = create;\n  /**\r\n   * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.\r\n   */\n\n  function is(value) {\n    var candidate = value;\n    return Range.is(candidate.range) && Color.is(candidate.color);\n  }\n\n  ColorInformation.is = is;\n})(ColorInformation || (ColorInformation = {}));\n/**\r\n * The Color namespace provides helper functions to work with\r\n * [ColorPresentation](#ColorPresentation) literals.\r\n */\n\n\nexport var ColorPresentation;\n\n(function (ColorPresentation) {\n  /**\r\n   * Creates a new ColorInformation literal.\r\n   */\n  function create(label, textEdit, additionalTextEdits) {\n    return {\n      label: label,\n      textEdit: textEdit,\n      additionalTextEdits: additionalTextEdits\n    };\n  }\n\n  ColorPresentation.create = create;\n  /**\r\n   * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.\r\n   */\n\n  function is(value) {\n    var candidate = value;\n    return Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\n  }\n\n  ColorPresentation.is = is;\n})(ColorPresentation || (ColorPresentation = {}));\n/**\r\n * Enum of known range kinds\r\n */\n\n\nexport var FoldingRangeKind;\n\n(function (FoldingRangeKind) {\n  /**\r\n   * Folding range for a comment\r\n   */\n  FoldingRangeKind[\"Comment\"] = \"comment\";\n  /**\r\n   * Folding range for a imports or includes\r\n   */\n\n  FoldingRangeKind[\"Imports\"] = \"imports\";\n  /**\r\n   * Folding range for a region (e.g. `#region`)\r\n   */\n\n  FoldingRangeKind[\"Region\"] = \"region\";\n})(FoldingRangeKind || (FoldingRangeKind = {}));\n/**\r\n * The folding range namespace provides helper functions to work with\r\n * [FoldingRange](#FoldingRange) literals.\r\n */\n\n\nexport var FoldingRange;\n\n(function (FoldingRange) {\n  /**\r\n   * Creates a new FoldingRange literal.\r\n   */\n  function create(startLine, endLine, startCharacter, endCharacter, kind) {\n    var result = {\n      startLine: startLine,\n      endLine: endLine\n    };\n\n    if (Is.defined(startCharacter)) {\n      result.startCharacter = startCharacter;\n    }\n\n    if (Is.defined(endCharacter)) {\n      result.endCharacter = endCharacter;\n    }\n\n    if (Is.defined(kind)) {\n      result.kind = kind;\n    }\n\n    return result;\n  }\n\n  FoldingRange.create = create;\n  /**\r\n   * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.\r\n   */\n\n  function is(value) {\n    var candidate = value;\n    return Is.number(candidate.startLine) && Is.number(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.number(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.number(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\n  }\n\n  FoldingRange.is = is;\n})(FoldingRange || (FoldingRange = {}));\n/**\r\n * The DiagnosticRelatedInformation namespace provides helper functions to work with\r\n * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.\r\n */\n\n\nexport var DiagnosticRelatedInformation;\n\n(function (DiagnosticRelatedInformation) {\n  /**\r\n   * Creates a new DiagnosticRelatedInformation literal.\r\n   */\n  function create(location, message) {\n    return {\n      location: location,\n      message: message\n    };\n  }\n\n  DiagnosticRelatedInformation.create = create;\n  /**\r\n   * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.\r\n   */\n\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\n  }\n\n  DiagnosticRelatedInformation.is = is;\n})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));\n/**\r\n * The diagnostic's severity.\r\n */\n\n\nexport var DiagnosticSeverity;\n\n(function (DiagnosticSeverity) {\n  /**\r\n   * Reports an error.\r\n   */\n  DiagnosticSeverity.Error = 1;\n  /**\r\n   * Reports a warning.\r\n   */\n\n  DiagnosticSeverity.Warning = 2;\n  /**\r\n   * Reports an information.\r\n   */\n\n  DiagnosticSeverity.Information = 3;\n  /**\r\n   * Reports a hint.\r\n   */\n\n  DiagnosticSeverity.Hint = 4;\n})(DiagnosticSeverity || (DiagnosticSeverity = {}));\n/**\r\n * The Diagnostic namespace provides helper functions to work with\r\n * [Diagnostic](#Diagnostic) literals.\r\n */\n\n\nexport var Diagnostic;\n\n(function (Diagnostic) {\n  /**\r\n   * Creates a new Diagnostic literal.\r\n   */\n  function create(range, message, severity, code, source, relatedInformation) {\n    var result = {\n      range: range,\n      message: message\n    };\n\n    if (Is.defined(severity)) {\n      result.severity = severity;\n    }\n\n    if (Is.defined(code)) {\n      result.code = code;\n    }\n\n    if (Is.defined(source)) {\n      result.source = source;\n    }\n\n    if (Is.defined(relatedInformation)) {\n      result.relatedInformation = relatedInformation;\n    }\n\n    return result;\n  }\n\n  Diagnostic.create = create;\n  /**\r\n   * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.\r\n   */\n\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.number(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\n  }\n\n  Diagnostic.is = is;\n})(Diagnostic || (Diagnostic = {}));\n/**\r\n * The Command namespace provides helper functions to work with\r\n * [Command](#Command) literals.\r\n */\n\n\nexport var Command;\n\n(function (Command) {\n  /**\r\n   * Creates a new Command literal.\r\n   */\n  function create(title, command) {\n    var args = [];\n\n    for (var _i = 2; _i < arguments.length; _i++) {\n      args[_i - 2] = arguments[_i];\n    }\n\n    var result = {\n      title: title,\n      command: command\n    };\n\n    if (Is.defined(args) && args.length > 0) {\n      result.arguments = args;\n    }\n\n    return result;\n  }\n\n  Command.create = create;\n  /**\r\n   * Checks whether the given literal conforms to the [Command](#Command) interface.\r\n   */\n\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\n  }\n\n  Command.is = is;\n})(Command || (Command = {}));\n/**\r\n * The TextEdit namespace provides helper function to create replace,\r\n * insert and delete edits more easily.\r\n */\n\n\nexport var TextEdit;\n\n(function (TextEdit) {\n  /**\r\n   * Creates a replace text edit.\r\n   * @param range The range of text to be replaced.\r\n   * @param newText The new text.\r\n   */\n  function replace(range, newText) {\n    return {\n      range: range,\n      newText: newText\n    };\n  }\n\n  TextEdit.replace = replace;\n  /**\r\n   * Creates a insert text edit.\r\n   * @param position The position to insert the text at.\r\n   * @param newText The text to be inserted.\r\n   */\n\n  function insert(position, newText) {\n    return {\n      range: {\n        start: position,\n        end: position\n      },\n      newText: newText\n    };\n  }\n\n  TextEdit.insert = insert;\n  /**\r\n   * Creates a delete text edit.\r\n   * @param range The range of text to be deleted.\r\n   */\n\n  function del(range) {\n    return {\n      range: range,\n      newText: ''\n    };\n  }\n\n  TextEdit.del = del;\n\n  function is(value) {\n    var candidate = value;\n    return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);\n  }\n\n  TextEdit.is = is;\n})(TextEdit || (TextEdit = {}));\n/**\r\n * The TextDocumentEdit namespace provides helper function to create\r\n * an edit that manipulates a text document.\r\n */\n\n\nexport var TextDocumentEdit;\n\n(function (TextDocumentEdit) {\n  /**\r\n   * Creates a new `TextDocumentEdit`\r\n   */\n  function create(textDocument, edits) {\n    return {\n      textDocument: textDocument,\n      edits: edits\n    };\n  }\n\n  TextDocumentEdit.create = create;\n\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) && VersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);\n  }\n\n  TextDocumentEdit.is = is;\n})(TextDocumentEdit || (TextDocumentEdit = {}));\n\nexport var CreateFile;\n\n(function (CreateFile) {\n  function create(uri, options) {\n    var result = {\n      kind: 'create',\n      uri: uri\n    };\n\n    if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {\n      result.options = options;\n    }\n\n    return result;\n  }\n\n  CreateFile.create = create;\n\n  function is(value) {\n    var candidate = value;\n    return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists)));\n  }\n\n  CreateFile.is = is;\n})(CreateFile || (CreateFile = {}));\n\nexport var RenameFile;\n\n(function (RenameFile) {\n  function create(oldUri, newUri, options) {\n    var result = {\n      kind: 'rename',\n      oldUri: oldUri,\n      newUri: newUri\n    };\n\n    if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {\n      result.options = options;\n    }\n\n    return result;\n  }\n\n  RenameFile.create = create;\n\n  function is(value) {\n    var candidate = value;\n    return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists)));\n  }\n\n  RenameFile.is = is;\n})(RenameFile || (RenameFile = {}));\n\nexport var DeleteFile;\n\n(function (DeleteFile) {\n  function create(uri, options) {\n    var result = {\n      kind: 'delete',\n      uri: uri\n    };\n\n    if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {\n      result.options = options;\n    }\n\n    return result;\n  }\n\n  DeleteFile.create = create;\n\n  function is(value) {\n    var candidate = value;\n    return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists)));\n  }\n\n  DeleteFile.is = is;\n})(DeleteFile || (DeleteFile = {}));\n\nexport var WorkspaceEdit;\n\n(function (WorkspaceEdit) {\n  function is(value) {\n    var candidate = value;\n    return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function (change) {\n      if (Is.string(change.kind)) {\n        return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\n      } else {\n        return TextDocumentEdit.is(change);\n      }\n    }));\n  }\n\n  WorkspaceEdit.is = is;\n})(WorkspaceEdit || (WorkspaceEdit = {}));\n\nvar TextEditChangeImpl =\n/** @class */\nfunction () {\n  function TextEditChangeImpl(edits) {\n    this.edits = edits;\n  }\n\n  TextEditChangeImpl.prototype.insert = function (position, newText) {\n    this.edits.push(TextEdit.insert(position, newText));\n  };\n\n  TextEditChangeImpl.prototype.replace = function (range, newText) {\n    this.edits.push(TextEdit.replace(range, newText));\n  };\n\n  TextEditChangeImpl.prototype.delete = function (range) {\n    this.edits.push(TextEdit.del(range));\n  };\n\n  TextEditChangeImpl.prototype.add = function (edit) {\n    this.edits.push(edit);\n  };\n\n  TextEditChangeImpl.prototype.all = function () {\n    return this.edits;\n  };\n\n  TextEditChangeImpl.prototype.clear = function () {\n    this.edits.splice(0, this.edits.length);\n  };\n\n  return TextEditChangeImpl;\n}();\n/**\r\n * A workspace change helps constructing changes to a workspace.\r\n */\n\n\nvar WorkspaceChange =\n/** @class */\nfunction () {\n  function WorkspaceChange(workspaceEdit) {\n    var _this = this;\n\n    this._textEditChanges = Object.create(null);\n\n    if (workspaceEdit) {\n      this._workspaceEdit = workspaceEdit;\n\n      if (workspaceEdit.documentChanges) {\n        workspaceEdit.documentChanges.forEach(function (change) {\n          if (TextDocumentEdit.is(change)) {\n            var textEditChange = new TextEditChangeImpl(change.edits);\n            _this._textEditChanges[change.textDocument.uri] = textEditChange;\n          }\n        });\n      } else if (workspaceEdit.changes) {\n        Object.keys(workspaceEdit.changes).forEach(function (key) {\n          var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);\n          _this._textEditChanges[key] = textEditChange;\n        });\n      }\n    }\n  }\n\n  Object.defineProperty(WorkspaceChange.prototype, \"edit\", {\n    /**\r\n     * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal\r\n     * use to be returned from a workspace edit operation like rename.\r\n     */\n    get: function get() {\n      return this._workspaceEdit;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  WorkspaceChange.prototype.getTextEditChange = function (key) {\n    if (VersionedTextDocumentIdentifier.is(key)) {\n      if (!this._workspaceEdit) {\n        this._workspaceEdit = {\n          documentChanges: []\n        };\n      }\n\n      if (!this._workspaceEdit.documentChanges) {\n        throw new Error('Workspace edit is not configured for document changes.');\n      }\n\n      var textDocument = key;\n      var result = this._textEditChanges[textDocument.uri];\n\n      if (!result) {\n        var edits = [];\n        var textDocumentEdit = {\n          textDocument: textDocument,\n          edits: edits\n        };\n\n        this._workspaceEdit.documentChanges.push(textDocumentEdit);\n\n        result = new TextEditChangeImpl(edits);\n        this._textEditChanges[textDocument.uri] = result;\n      }\n\n      return result;\n    } else {\n      if (!this._workspaceEdit) {\n        this._workspaceEdit = {\n          changes: Object.create(null)\n        };\n      }\n\n      if (!this._workspaceEdit.changes) {\n        throw new Error('Workspace edit is not configured for normal text edit changes.');\n      }\n\n      var result = this._textEditChanges[key];\n\n      if (!result) {\n        var edits = [];\n        this._workspaceEdit.changes[key] = edits;\n        result = new TextEditChangeImpl(edits);\n        this._textEditChanges[key] = result;\n      }\n\n      return result;\n    }\n  };\n\n  WorkspaceChange.prototype.createFile = function (uri, options) {\n    this.checkDocumentChanges();\n\n    this._workspaceEdit.documentChanges.push(CreateFile.create(uri, options));\n  };\n\n  WorkspaceChange.prototype.renameFile = function (oldUri, newUri, options) {\n    this.checkDocumentChanges();\n\n    this._workspaceEdit.documentChanges.push(RenameFile.create(oldUri, newUri, options));\n  };\n\n  WorkspaceChange.prototype.deleteFile = function (uri, options) {\n    this.checkDocumentChanges();\n\n    this._workspaceEdit.documentChanges.push(DeleteFile.create(uri, options));\n  };\n\n  WorkspaceChange.prototype.checkDocumentChanges = function () {\n    if (!this._workspaceEdit || !this._workspaceEdit.documentChanges) {\n      throw new Error('Workspace edit is not configured for document changes.');\n    }\n  };\n\n  return WorkspaceChange;\n}();\n\nexport { WorkspaceChange };\n/**\r\n * The TextDocumentIdentifier namespace provides helper functions to work with\r\n * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.\r\n */\n\nexport var TextDocumentIdentifier;\n\n(function (TextDocumentIdentifier) {\n  /**\r\n   * Creates a new TextDocumentIdentifier literal.\r\n   * @param uri The document's uri.\r\n   */\n  function create(uri) {\n    return {\n      uri: uri\n    };\n  }\n\n  TextDocumentIdentifier.create = create;\n  /**\r\n   * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.\r\n   */\n\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) && Is.string(candidate.uri);\n  }\n\n  TextDocumentIdentifier.is = is;\n})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));\n/**\r\n * The VersionedTextDocumentIdentifier namespace provides helper functions to work with\r\n * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.\r\n */\n\n\nexport var VersionedTextDocumentIdentifier;\n\n(function (VersionedTextDocumentIdentifier) {\n  /**\r\n   * Creates a new VersionedTextDocumentIdentifier literal.\r\n   * @param uri The document's uri.\r\n   * @param uri The document's text.\r\n   */\n  function create(uri, version) {\n    return {\n      uri: uri,\n      version: version\n    };\n  }\n\n  VersionedTextDocumentIdentifier.create = create;\n  /**\r\n   * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.\r\n   */\n\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.number(candidate.version));\n  }\n\n  VersionedTextDocumentIdentifier.is = is;\n})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));\n/**\r\n * The TextDocumentItem namespace provides helper functions to work with\r\n * [TextDocumentItem](#TextDocumentItem) literals.\r\n */\n\n\nexport var TextDocumentItem;\n\n(function (TextDocumentItem) {\n  /**\r\n   * Creates a new TextDocumentItem literal.\r\n   * @param uri The document's uri.\r\n   * @param languageId The document's language identifier.\r\n   * @param version The document's version number.\r\n   * @param text The document's text.\r\n   */\n  function create(uri, languageId, version, text) {\n    return {\n      uri: uri,\n      languageId: languageId,\n      version: version,\n      text: text\n    };\n  }\n\n  TextDocumentItem.create = create;\n  /**\r\n   * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.\r\n   */\n\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.number(candidate.version) && Is.string(candidate.text);\n  }\n\n  TextDocumentItem.is = is;\n})(TextDocumentItem || (TextDocumentItem = {}));\n/**\r\n * Describes the content type that a client supports in various\r\n * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\r\n *\r\n * Please note that `MarkupKinds` must not start with a `$`. This kinds\r\n * are reserved for internal usage.\r\n */\n\n\nexport var MarkupKind;\n\n(function (MarkupKind) {\n  /**\r\n   * Plain text is supported as a content format\r\n   */\n  MarkupKind.PlainText = 'plaintext';\n  /**\r\n   * Markdown is supported as a content format\r\n   */\n\n  MarkupKind.Markdown = 'markdown';\n})(MarkupKind || (MarkupKind = {}));\n\n(function (MarkupKind) {\n  /**\r\n   * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.\r\n   */\n  function is(value) {\n    var candidate = value;\n    return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;\n  }\n\n  MarkupKind.is = is;\n})(MarkupKind || (MarkupKind = {}));\n\nexport var MarkupContent;\n\n(function (MarkupContent) {\n  /**\r\n   * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.\r\n   */\n  function is(value) {\n    var candidate = value;\n    return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\n  }\n\n  MarkupContent.is = is;\n})(MarkupContent || (MarkupContent = {}));\n/**\r\n * The kind of a completion entry.\r\n */\n\n\nexport var CompletionItemKind;\n\n(function (CompletionItemKind) {\n  CompletionItemKind.Text = 1;\n  CompletionItemKind.Method = 2;\n  CompletionItemKind.Function = 3;\n  CompletionItemKind.Constructor = 4;\n  CompletionItemKind.Field = 5;\n  CompletionItemKind.Variable = 6;\n  CompletionItemKind.Class = 7;\n  CompletionItemKind.Interface = 8;\n  CompletionItemKind.Module = 9;\n  CompletionItemKind.Property = 10;\n  CompletionItemKind.Unit = 11;\n  CompletionItemKind.Value = 12;\n  CompletionItemKind.Enum = 13;\n  CompletionItemKind.Keyword = 14;\n  CompletionItemKind.Snippet = 15;\n  CompletionItemKind.Color = 16;\n  CompletionItemKind.File = 17;\n  CompletionItemKind.Reference = 18;\n  CompletionItemKind.Folder = 19;\n  CompletionItemKind.EnumMember = 20;\n  CompletionItemKind.Constant = 21;\n  CompletionItemKind.Struct = 22;\n  CompletionItemKind.Event = 23;\n  CompletionItemKind.Operator = 24;\n  CompletionItemKind.TypeParameter = 25;\n})(CompletionItemKind || (CompletionItemKind = {}));\n/**\r\n * Defines whether the insert text in a completion item should be interpreted as\r\n * plain text or a snippet.\r\n */\n\n\nexport var InsertTextFormat;\n\n(function (InsertTextFormat) {\n  /**\r\n   * The primary text to be inserted is treated as a plain string.\r\n   */\n  InsertTextFormat.PlainText = 1;\n  /**\r\n   * The primary text to be inserted is treated as a snippet.\r\n   *\r\n   * A snippet can define tab stops and placeholders with `$1`, `$2`\r\n   * and `${3:foo}`. `$0` defines the final tab stop, it defaults to\r\n   * the end of the snippet. Placeholders with equal identifiers are linked,\r\n   * that is typing in one will update others too.\r\n   *\r\n   * See also: https://github.com/Microsoft/vscode/blob/master/src/vs/editor/contrib/snippet/common/snippet.md\r\n   */\n\n  InsertTextFormat.Snippet = 2;\n})(InsertTextFormat || (InsertTextFormat = {}));\n/**\r\n * The CompletionItem namespace provides functions to deal with\r\n * completion items.\r\n */\n\n\nexport var CompletionItem;\n\n(function (CompletionItem) {\n  /**\r\n   * Create a completion item and seed it with a label.\r\n   * @param label The completion item's label\r\n   */\n  function create(label) {\n    return {\n      label: label\n    };\n  }\n\n  CompletionItem.create = create;\n})(CompletionItem || (CompletionItem = {}));\n/**\r\n * The CompletionList namespace provides functions to deal with\r\n * completion lists.\r\n */\n\n\nexport var CompletionList;\n\n(function (CompletionList) {\n  /**\r\n   * Creates a new completion list.\r\n   *\r\n   * @param items The completion items.\r\n   * @param isIncomplete The list is not complete.\r\n   */\n  function create(items, isIncomplete) {\n    return {\n      items: items ? items : [],\n      isIncomplete: !!isIncomplete\n    };\n  }\n\n  CompletionList.create = create;\n})(CompletionList || (CompletionList = {}));\n\nexport var MarkedString;\n\n(function (MarkedString) {\n  /**\r\n   * Creates a marked string from plain text.\r\n   *\r\n   * @param plainText The plain text.\r\n   */\n  function fromPlainText(plainText) {\n    return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, \"\\\\$&\"); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\n  }\n\n  MarkedString.fromPlainText = fromPlainText;\n  /**\r\n   * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.\r\n   */\n\n  function is(value) {\n    var candidate = value;\n    return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);\n  }\n\n  MarkedString.is = is;\n})(MarkedString || (MarkedString = {}));\n\nexport var Hover;\n\n(function (Hover) {\n  /**\r\n   * Checks whether the given value conforms to the [Hover](#Hover) interface.\r\n   */\n  function is(value) {\n    var candidate = value;\n    return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));\n  }\n\n  Hover.is = is;\n})(Hover || (Hover = {}));\n/**\r\n * The ParameterInformation namespace provides helper functions to work with\r\n * [ParameterInformation](#ParameterInformation) literals.\r\n */\n\n\nexport var ParameterInformation;\n\n(function (ParameterInformation) {\n  /**\r\n   * Creates a new parameter information literal.\r\n   *\r\n   * @param label A label string.\r\n   * @param documentation A doc string.\r\n   */\n  function create(label, documentation) {\n    return documentation ? {\n      label: label,\n      documentation: documentation\n    } : {\n      label: label\n    };\n  }\n\n  ParameterInformation.create = create;\n  ;\n})(ParameterInformation || (ParameterInformation = {}));\n/**\r\n * The SignatureInformation namespace provides helper functions to work with\r\n * [SignatureInformation](#SignatureInformation) literals.\r\n */\n\n\nexport var SignatureInformation;\n\n(function (SignatureInformation) {\n  function create(label, documentation) {\n    var parameters = [];\n\n    for (var _i = 2; _i < arguments.length; _i++) {\n      parameters[_i - 2] = arguments[_i];\n    }\n\n    var result = {\n      label: label\n    };\n\n    if (Is.defined(documentation)) {\n      result.documentation = documentation;\n    }\n\n    if (Is.defined(parameters)) {\n      result.parameters = parameters;\n    } else {\n      result.parameters = [];\n    }\n\n    return result;\n  }\n\n  SignatureInformation.create = create;\n})(SignatureInformation || (SignatureInformation = {}));\n/**\r\n * A document highlight kind.\r\n */\n\n\nexport var DocumentHighlightKind;\n\n(function (DocumentHighlightKind) {\n  /**\r\n   * A textual occurrence.\r\n   */\n  DocumentHighlightKind.Text = 1;\n  /**\r\n   * Read-access of a symbol, like reading a variable.\r\n   */\n\n  DocumentHighlightKind.Read = 2;\n  /**\r\n   * Write-access of a symbol, like writing to a variable.\r\n   */\n\n  DocumentHighlightKind.Write = 3;\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\n/**\r\n * DocumentHighlight namespace to provide helper functions to work with\r\n * [DocumentHighlight](#DocumentHighlight) literals.\r\n */\n\n\nexport var DocumentHighlight;\n\n(function (DocumentHighlight) {\n  /**\r\n   * Create a DocumentHighlight object.\r\n   * @param range The range the highlight applies to.\r\n   */\n  function create(range, kind) {\n    var result = {\n      range: range\n    };\n\n    if (Is.number(kind)) {\n      result.kind = kind;\n    }\n\n    return result;\n  }\n\n  DocumentHighlight.create = create;\n})(DocumentHighlight || (DocumentHighlight = {}));\n/**\r\n * A symbol kind.\r\n */\n\n\nexport var SymbolKind;\n\n(function (SymbolKind) {\n  SymbolKind.File = 1;\n  SymbolKind.Module = 2;\n  SymbolKind.Namespace = 3;\n  SymbolKind.Package = 4;\n  SymbolKind.Class = 5;\n  SymbolKind.Method = 6;\n  SymbolKind.Property = 7;\n  SymbolKind.Field = 8;\n  SymbolKind.Constructor = 9;\n  SymbolKind.Enum = 10;\n  SymbolKind.Interface = 11;\n  SymbolKind.Function = 12;\n  SymbolKind.Variable = 13;\n  SymbolKind.Constant = 14;\n  SymbolKind.String = 15;\n  SymbolKind.Number = 16;\n  SymbolKind.Boolean = 17;\n  SymbolKind.Array = 18;\n  SymbolKind.Object = 19;\n  SymbolKind.Key = 20;\n  SymbolKind.Null = 21;\n  SymbolKind.EnumMember = 22;\n  SymbolKind.Struct = 23;\n  SymbolKind.Event = 24;\n  SymbolKind.Operator = 25;\n  SymbolKind.TypeParameter = 26;\n})(SymbolKind || (SymbolKind = {}));\n\nexport var SymbolInformation;\n\n(function (SymbolInformation) {\n  /**\r\n   * Creates a new symbol information literal.\r\n   *\r\n   * @param name The name of the symbol.\r\n   * @param kind The kind of the symbol.\r\n   * @param range The range of the location of the symbol.\r\n   * @param uri The resource of the location of symbol, defaults to the current document.\r\n   * @param containerName The name of the symbol containing the symbol.\r\n   */\n  function create(name, kind, range, uri, containerName) {\n    var result = {\n      name: name,\n      kind: kind,\n      location: {\n        uri: uri,\n        range: range\n      }\n    };\n\n    if (containerName) {\n      result.containerName = containerName;\n    }\n\n    return result;\n  }\n\n  SymbolInformation.create = create;\n})(SymbolInformation || (SymbolInformation = {}));\n/**\r\n * Represents programming constructs like variables, classes, interfaces etc.\r\n * that appear in a document. Document symbols can be hierarchical and they\r\n * have two ranges: one that encloses its definition and one that points to\r\n * its most interesting range, e.g. the range of an identifier.\r\n */\n\n\nvar DocumentSymbol =\n/** @class */\nfunction () {\n  function DocumentSymbol() {}\n\n  return DocumentSymbol;\n}();\n\nexport { DocumentSymbol };\n\n(function (DocumentSymbol) {\n  /**\r\n   * Creates a new symbol information literal.\r\n   *\r\n   * @param name The name of the symbol.\r\n   * @param detail The detail of the symbol.\r\n   * @param kind The kind of the symbol.\r\n   * @param range The range of the symbol.\r\n   * @param selectionRange The selectionRange of the symbol.\r\n   * @param children Children of the symbol.\r\n   */\n  function create(name, detail, kind, range, selectionRange, children) {\n    var result = {\n      name: name,\n      detail: detail,\n      kind: kind,\n      range: range,\n      selectionRange: selectionRange\n    };\n\n    if (children !== void 0) {\n      result.children = children;\n    }\n\n    return result;\n  }\n\n  DocumentSymbol.create = create;\n  /**\r\n   * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.\r\n   */\n\n  function is(value) {\n    var candidate = value;\n    return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children));\n  }\n\n  DocumentSymbol.is = is;\n})(DocumentSymbol || (DocumentSymbol = {}));\n/**\r\n * A set of predefined code action kinds\r\n */\n\n\nexport var CodeActionKind;\n\n(function (CodeActionKind) {\n  /**\r\n   * Base kind for quickfix actions: 'quickfix'\r\n   */\n  CodeActionKind.QuickFix = 'quickfix';\n  /**\r\n   * Base kind for refactoring actions: 'refactor'\r\n   */\n\n  CodeActionKind.Refactor = 'refactor';\n  /**\r\n   * Base kind for refactoring extraction actions: 'refactor.extract'\r\n   *\r\n   * Example extract actions:\r\n   *\r\n   * - Extract method\r\n   * - Extract function\r\n   * - Extract variable\r\n   * - Extract interface from class\r\n   * - ...\r\n   */\n\n  CodeActionKind.RefactorExtract = 'refactor.extract';\n  /**\r\n   * Base kind for refactoring inline actions: 'refactor.inline'\r\n   *\r\n   * Example inline actions:\r\n   *\r\n   * - Inline function\r\n   * - Inline variable\r\n   * - Inline constant\r\n   * - ...\r\n   */\n\n  CodeActionKind.RefactorInline = 'refactor.inline';\n  /**\r\n   * Base kind for refactoring rewrite actions: 'refactor.rewrite'\r\n   *\r\n   * Example rewrite actions:\r\n   *\r\n   * - Convert JavaScript function to class\r\n   * - Add or remove parameter\r\n   * - Encapsulate field\r\n   * - Make method static\r\n   * - Move method to base class\r\n   * - ...\r\n   */\n\n  CodeActionKind.RefactorRewrite = 'refactor.rewrite';\n  /**\r\n   * Base kind for source actions: `source`\r\n   *\r\n   * Source code actions apply to the entire file.\r\n   */\n\n  CodeActionKind.Source = 'source';\n  /**\r\n   * Base kind for an organize imports source action: `source.organizeImports`\r\n   */\n\n  CodeActionKind.SourceOrganizeImports = 'source.organizeImports';\n})(CodeActionKind || (CodeActionKind = {}));\n/**\r\n * The CodeActionContext namespace provides helper functions to work with\r\n * [CodeActionContext](#CodeActionContext) literals.\r\n */\n\n\nexport var CodeActionContext;\n\n(function (CodeActionContext) {\n  /**\r\n   * Creates a new CodeActionContext literal.\r\n   */\n  function create(diagnostics, only) {\n    var result = {\n      diagnostics: diagnostics\n    };\n\n    if (only !== void 0 && only !== null) {\n      result.only = only;\n    }\n\n    return result;\n  }\n\n  CodeActionContext.create = create;\n  /**\r\n   * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.\r\n   */\n\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string));\n  }\n\n  CodeActionContext.is = is;\n})(CodeActionContext || (CodeActionContext = {}));\n\nexport var CodeAction;\n\n(function (CodeAction) {\n  function create(title, commandOrEdit, kind) {\n    var result = {\n      title: title\n    };\n\n    if (Command.is(commandOrEdit)) {\n      result.command = commandOrEdit;\n    } else {\n      result.edit = commandOrEdit;\n    }\n\n    if (kind !== void null) {\n      result.kind = kind;\n    }\n\n    return result;\n  }\n\n  CodeAction.create = create;\n\n  function is(value) {\n    var candidate = value;\n    return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));\n  }\n\n  CodeAction.is = is;\n})(CodeAction || (CodeAction = {}));\n/**\r\n * The CodeLens namespace provides helper functions to work with\r\n * [CodeLens](#CodeLens) literals.\r\n */\n\n\nexport var CodeLens;\n\n(function (CodeLens) {\n  /**\r\n   * Creates a new CodeLens literal.\r\n   */\n  function create(range, data) {\n    var result = {\n      range: range\n    };\n    if (Is.defined(data)) result.data = data;\n    return result;\n  }\n\n  CodeLens.create = create;\n  /**\r\n   * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.\r\n   */\n\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\n  }\n\n  CodeLens.is = is;\n})(CodeLens || (CodeLens = {}));\n/**\r\n * The FormattingOptions namespace provides helper functions to work with\r\n * [FormattingOptions](#FormattingOptions) literals.\r\n */\n\n\nexport var FormattingOptions;\n\n(function (FormattingOptions) {\n  /**\r\n   * Creates a new FormattingOptions literal.\r\n   */\n  function create(tabSize, insertSpaces) {\n    return {\n      tabSize: tabSize,\n      insertSpaces: insertSpaces\n    };\n  }\n\n  FormattingOptions.create = create;\n  /**\r\n   * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.\r\n   */\n\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) && Is.number(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\n  }\n\n  FormattingOptions.is = is;\n})(FormattingOptions || (FormattingOptions = {}));\n/**\r\n * A document link is a range in a text document that links to an internal or external resource, like another\r\n * text document or a web site.\r\n */\n\n\nvar DocumentLink =\n/** @class */\nfunction () {\n  function DocumentLink() {}\n\n  return DocumentLink;\n}();\n\nexport { DocumentLink };\n/**\r\n * The DocumentLink namespace provides helper functions to work with\r\n * [DocumentLink](#DocumentLink) literals.\r\n */\n\n(function (DocumentLink) {\n  /**\r\n   * Creates a new DocumentLink literal.\r\n   */\n  function create(range, target, data) {\n    return {\n      range: range,\n      target: target,\n      data: data\n    };\n  }\n\n  DocumentLink.create = create;\n  /**\r\n   * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.\r\n   */\n\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\n  }\n\n  DocumentLink.is = is;\n})(DocumentLink || (DocumentLink = {}));\n\nexport var EOL = ['\\n', '\\r\\n', '\\r'];\nexport var TextDocument;\n\n(function (TextDocument) {\n  /**\r\n   * Creates a new ITextDocument literal from the given uri and content.\r\n   * @param uri The document's uri.\r\n   * @param languageId  The document's language Id.\r\n   * @param content The document's content.\r\n   */\n  function create(uri, languageId, version, content) {\n    return new FullTextDocument(uri, languageId, version, content);\n  }\n\n  TextDocument.create = create;\n  /**\r\n   * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.\r\n   */\n\n  function is(value) {\n    var candidate = value;\n    return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.number(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\n  }\n\n  TextDocument.is = is;\n\n  function applyEdits(document, edits) {\n    var text = document.getText();\n    var sortedEdits = mergeSort(edits, function (a, b) {\n      var diff = a.range.start.line - b.range.start.line;\n\n      if (diff === 0) {\n        return a.range.start.character - b.range.start.character;\n      }\n\n      return diff;\n    });\n    var lastModifiedOffset = text.length;\n\n    for (var i = sortedEdits.length - 1; i >= 0; i--) {\n      var e = sortedEdits[i];\n      var startOffset = document.offsetAt(e.range.start);\n      var endOffset = document.offsetAt(e.range.end);\n\n      if (endOffset <= lastModifiedOffset) {\n        text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\n      } else {\n        throw new Error('Overlapping edit');\n      }\n\n      lastModifiedOffset = startOffset;\n    }\n\n    return text;\n  }\n\n  TextDocument.applyEdits = applyEdits;\n\n  function mergeSort(data, compare) {\n    if (data.length <= 1) {\n      // sorted\n      return data;\n    }\n\n    var p = data.length / 2 | 0;\n    var left = data.slice(0, p);\n    var right = data.slice(p);\n    mergeSort(left, compare);\n    mergeSort(right, compare);\n    var leftIdx = 0;\n    var rightIdx = 0;\n    var i = 0;\n\n    while (leftIdx < left.length && rightIdx < right.length) {\n      var ret = compare(left[leftIdx], right[rightIdx]);\n\n      if (ret <= 0) {\n        // smaller_equal -> take left to preserve order\n        data[i++] = left[leftIdx++];\n      } else {\n        // greater -> take right\n        data[i++] = right[rightIdx++];\n      }\n    }\n\n    while (leftIdx < left.length) {\n      data[i++] = left[leftIdx++];\n    }\n\n    while (rightIdx < right.length) {\n      data[i++] = right[rightIdx++];\n    }\n\n    return data;\n  }\n})(TextDocument || (TextDocument = {}));\n/**\r\n * Represents reasons why a text document is saved.\r\n */\n\n\nexport var TextDocumentSaveReason;\n\n(function (TextDocumentSaveReason) {\n  /**\r\n   * Manually triggered, e.g. by the user pressing save, by starting debugging,\r\n   * or by an API call.\r\n   */\n  TextDocumentSaveReason.Manual = 1;\n  /**\r\n   * Automatic after a delay.\r\n   */\n\n  TextDocumentSaveReason.AfterDelay = 2;\n  /**\r\n   * When the editor lost focus.\r\n   */\n\n  TextDocumentSaveReason.FocusOut = 3;\n})(TextDocumentSaveReason || (TextDocumentSaveReason = {}));\n\nvar FullTextDocument =\n/** @class */\nfunction () {\n  function FullTextDocument(uri, languageId, version, content) {\n    this._uri = uri;\n    this._languageId = languageId;\n    this._version = version;\n    this._content = content;\n    this._lineOffsets = null;\n  }\n\n  Object.defineProperty(FullTextDocument.prototype, \"uri\", {\n    get: function get() {\n      return this._uri;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\n    get: function get() {\n      return this._languageId;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FullTextDocument.prototype, \"version\", {\n    get: function get() {\n      return this._version;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  FullTextDocument.prototype.getText = function (range) {\n    if (range) {\n      var start = this.offsetAt(range.start);\n      var end = this.offsetAt(range.end);\n      return this._content.substring(start, end);\n    }\n\n    return this._content;\n  };\n\n  FullTextDocument.prototype.update = function (event, version) {\n    this._content = event.text;\n    this._version = version;\n    this._lineOffsets = null;\n  };\n\n  FullTextDocument.prototype.getLineOffsets = function () {\n    if (this._lineOffsets === null) {\n      var lineOffsets = [];\n      var text = this._content;\n      var isLineStart = true;\n\n      for (var i = 0; i < text.length; i++) {\n        if (isLineStart) {\n          lineOffsets.push(i);\n          isLineStart = false;\n        }\n\n        var ch = text.charAt(i);\n        isLineStart = ch === '\\r' || ch === '\\n';\n\n        if (ch === '\\r' && i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n          i++;\n        }\n      }\n\n      if (isLineStart && text.length > 0) {\n        lineOffsets.push(text.length);\n      }\n\n      this._lineOffsets = lineOffsets;\n    }\n\n    return this._lineOffsets;\n  };\n\n  FullTextDocument.prototype.positionAt = function (offset) {\n    offset = Math.max(Math.min(offset, this._content.length), 0);\n    var lineOffsets = this.getLineOffsets();\n    var low = 0,\n        high = lineOffsets.length;\n\n    if (high === 0) {\n      return Position.create(0, offset);\n    }\n\n    while (low < high) {\n      var mid = Math.floor((low + high) / 2);\n\n      if (lineOffsets[mid] > offset) {\n        high = mid;\n      } else {\n        low = mid + 1;\n      }\n    } // low is the least x for which the line offset is larger than the current offset\n    // or array.length if no line offset is larger than the current offset\n\n\n    var line = low - 1;\n    return Position.create(line, offset - lineOffsets[line]);\n  };\n\n  FullTextDocument.prototype.offsetAt = function (position) {\n    var lineOffsets = this.getLineOffsets();\n\n    if (position.line >= lineOffsets.length) {\n      return this._content.length;\n    } else if (position.line < 0) {\n      return 0;\n    }\n\n    var lineOffset = lineOffsets[position.line];\n    var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;\n    return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n  };\n\n  Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\n    get: function get() {\n      return this.getLineOffsets().length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return FullTextDocument;\n}();\n\nvar Is;\n\n(function (Is) {\n  var toString = Object.prototype.toString;\n\n  function defined(value) {\n    return typeof value !== 'undefined';\n  }\n\n  Is.defined = defined;\n\n  function undefined(value) {\n    return typeof value === 'undefined';\n  }\n\n  Is.undefined = undefined;\n\n  function boolean(value) {\n    return value === true || value === false;\n  }\n\n  Is.boolean = boolean;\n\n  function string(value) {\n    return toString.call(value) === '[object String]';\n  }\n\n  Is.string = string;\n\n  function number(value) {\n    return toString.call(value) === '[object Number]';\n  }\n\n  Is.number = number;\n\n  function func(value) {\n    return toString.call(value) === '[object Function]';\n  }\n\n  Is.func = func;\n\n  function objectLiteral(value) {\n    // Strictly speaking class instances pass this check as well. Since the LSP\n    // doesn't use classes we ignore this for now. If we do we need to add something\n    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\n    return value !== null && typeof value === 'object';\n  }\n\n  Is.objectLiteral = objectLiteral;\n\n  function typedArray(value, check) {\n    return Array.isArray(value) && value.every(check);\n  }\n\n  Is.typedArray = typedArray;\n})(Is || (Is = {}));","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport * as ls from './_deps/vscode-languageserver-types/main.js';\nvar Uri = monaco.Uri;\nvar Range = monaco.Range; // --- diagnostics --- ---\n\nvar DiagnosticsAdapter =\n/** @class */\nfunction () {\n  function DiagnosticsAdapter(_languageId, _worker, defaults) {\n    var _this = this;\n\n    this._languageId = _languageId;\n    this._worker = _worker;\n    this._disposables = [];\n    this._listener = Object.create(null);\n\n    var onModelAdd = function onModelAdd(model) {\n      var modeId = model.getModeId();\n\n      if (modeId !== _this._languageId) {\n        return;\n      }\n\n      var handle;\n      _this._listener[model.uri.toString()] = model.onDidChangeContent(function () {\n        clearTimeout(handle);\n        handle = setTimeout(function () {\n          return _this._doValidate(model.uri, modeId);\n        }, 500);\n      });\n\n      _this._doValidate(model.uri, modeId);\n    };\n\n    var onModelRemoved = function onModelRemoved(model) {\n      monaco.editor.setModelMarkers(model, _this._languageId, []);\n      var uriStr = model.uri.toString();\n      var listener = _this._listener[uriStr];\n\n      if (listener) {\n        listener.dispose();\n        delete _this._listener[uriStr];\n      }\n    };\n\n    this._disposables.push(monaco.editor.onDidCreateModel(onModelAdd));\n\n    this._disposables.push(monaco.editor.onWillDisposeModel(function (model) {\n      onModelRemoved(model);\n\n      _this._resetSchema(model.uri);\n    }));\n\n    this._disposables.push(monaco.editor.onDidChangeModelLanguage(function (event) {\n      onModelRemoved(event.model);\n      onModelAdd(event.model);\n\n      _this._resetSchema(event.model.uri);\n    }));\n\n    this._disposables.push(defaults.onDidChange(function (_) {\n      monaco.editor.getModels().forEach(function (model) {\n        if (model.getModeId() === _this._languageId) {\n          onModelRemoved(model);\n          onModelAdd(model);\n        }\n      });\n    }));\n\n    this._disposables.push({\n      dispose: function dispose() {\n        monaco.editor.getModels().forEach(onModelRemoved);\n\n        for (var key in _this._listener) {\n          _this._listener[key].dispose();\n        }\n      }\n    });\n\n    monaco.editor.getModels().forEach(onModelAdd);\n  }\n\n  DiagnosticsAdapter.prototype.dispose = function () {\n    this._disposables.forEach(function (d) {\n      return d && d.dispose();\n    });\n\n    this._disposables = [];\n  };\n\n  DiagnosticsAdapter.prototype._resetSchema = function (resource) {\n    this._worker().then(function (worker) {\n      worker.resetSchema(resource.toString());\n    });\n  };\n\n  DiagnosticsAdapter.prototype._doValidate = function (resource, languageId) {\n    this._worker(resource).then(function (worker) {\n      return worker.doValidation(resource.toString()).then(function (diagnostics) {\n        var markers = diagnostics.map(function (d) {\n          return toDiagnostics(resource, d);\n        });\n        var model = monaco.editor.getModel(resource);\n\n        if (model && model.getModeId() === languageId) {\n          monaco.editor.setModelMarkers(model, languageId, markers);\n        }\n      });\n    }).then(undefined, function (err) {\n      console.error(err);\n    });\n  };\n\n  return DiagnosticsAdapter;\n}();\n\nexport { DiagnosticsAdapter };\n\nfunction toSeverity(lsSeverity) {\n  switch (lsSeverity) {\n    case ls.DiagnosticSeverity.Error:\n      return monaco.MarkerSeverity.Error;\n\n    case ls.DiagnosticSeverity.Warning:\n      return monaco.MarkerSeverity.Warning;\n\n    case ls.DiagnosticSeverity.Information:\n      return monaco.MarkerSeverity.Info;\n\n    case ls.DiagnosticSeverity.Hint:\n      return monaco.MarkerSeverity.Hint;\n\n    default:\n      return monaco.MarkerSeverity.Info;\n  }\n}\n\nfunction toDiagnostics(resource, diag) {\n  var code = typeof diag.code === 'number' ? String(diag.code) : diag.code;\n  return {\n    severity: toSeverity(diag.severity),\n    startLineNumber: diag.range.start.line + 1,\n    startColumn: diag.range.start.character + 1,\n    endLineNumber: diag.range.end.line + 1,\n    endColumn: diag.range.end.character + 1,\n    message: diag.message,\n    code: code,\n    source: diag.source\n  };\n} // --- completion ------\n\n\nfunction fromPosition(position) {\n  if (!position) {\n    return void 0;\n  }\n\n  return {\n    character: position.column - 1,\n    line: position.lineNumber - 1\n  };\n}\n\nfunction fromRange(range) {\n  if (!range) {\n    return void 0;\n  }\n\n  return {\n    start: {\n      line: range.startLineNumber - 1,\n      character: range.startColumn - 1\n    },\n    end: {\n      line: range.endLineNumber - 1,\n      character: range.endColumn - 1\n    }\n  };\n}\n\nfunction toRange(range) {\n  if (!range) {\n    return void 0;\n  }\n\n  return new Range(range.start.line + 1, range.start.character + 1, range.end.line + 1, range.end.character + 1);\n}\n\nfunction toCompletionItemKind(kind) {\n  var mItemKind = monaco.languages.CompletionItemKind;\n\n  switch (kind) {\n    case ls.CompletionItemKind.Text:\n      return mItemKind.Text;\n\n    case ls.CompletionItemKind.Method:\n      return mItemKind.Method;\n\n    case ls.CompletionItemKind.Function:\n      return mItemKind.Function;\n\n    case ls.CompletionItemKind.Constructor:\n      return mItemKind.Constructor;\n\n    case ls.CompletionItemKind.Field:\n      return mItemKind.Field;\n\n    case ls.CompletionItemKind.Variable:\n      return mItemKind.Variable;\n\n    case ls.CompletionItemKind.Class:\n      return mItemKind.Class;\n\n    case ls.CompletionItemKind.Interface:\n      return mItemKind.Interface;\n\n    case ls.CompletionItemKind.Module:\n      return mItemKind.Module;\n\n    case ls.CompletionItemKind.Property:\n      return mItemKind.Property;\n\n    case ls.CompletionItemKind.Unit:\n      return mItemKind.Unit;\n\n    case ls.CompletionItemKind.Value:\n      return mItemKind.Value;\n\n    case ls.CompletionItemKind.Enum:\n      return mItemKind.Enum;\n\n    case ls.CompletionItemKind.Keyword:\n      return mItemKind.Keyword;\n\n    case ls.CompletionItemKind.Snippet:\n      return mItemKind.Snippet;\n\n    case ls.CompletionItemKind.Color:\n      return mItemKind.Color;\n\n    case ls.CompletionItemKind.File:\n      return mItemKind.File;\n\n    case ls.CompletionItemKind.Reference:\n      return mItemKind.Reference;\n  }\n\n  return mItemKind.Property;\n}\n\nfunction fromCompletionItemKind(kind) {\n  var mItemKind = monaco.languages.CompletionItemKind;\n\n  switch (kind) {\n    case mItemKind.Text:\n      return ls.CompletionItemKind.Text;\n\n    case mItemKind.Method:\n      return ls.CompletionItemKind.Method;\n\n    case mItemKind.Function:\n      return ls.CompletionItemKind.Function;\n\n    case mItemKind.Constructor:\n      return ls.CompletionItemKind.Constructor;\n\n    case mItemKind.Field:\n      return ls.CompletionItemKind.Field;\n\n    case mItemKind.Variable:\n      return ls.CompletionItemKind.Variable;\n\n    case mItemKind.Class:\n      return ls.CompletionItemKind.Class;\n\n    case mItemKind.Interface:\n      return ls.CompletionItemKind.Interface;\n\n    case mItemKind.Module:\n      return ls.CompletionItemKind.Module;\n\n    case mItemKind.Property:\n      return ls.CompletionItemKind.Property;\n\n    case mItemKind.Unit:\n      return ls.CompletionItemKind.Unit;\n\n    case mItemKind.Value:\n      return ls.CompletionItemKind.Value;\n\n    case mItemKind.Enum:\n      return ls.CompletionItemKind.Enum;\n\n    case mItemKind.Keyword:\n      return ls.CompletionItemKind.Keyword;\n\n    case mItemKind.Snippet:\n      return ls.CompletionItemKind.Snippet;\n\n    case mItemKind.Color:\n      return ls.CompletionItemKind.Color;\n\n    case mItemKind.File:\n      return ls.CompletionItemKind.File;\n\n    case mItemKind.Reference:\n      return ls.CompletionItemKind.Reference;\n  }\n\n  return ls.CompletionItemKind.Property;\n}\n\nfunction toTextEdit(textEdit) {\n  if (!textEdit) {\n    return void 0;\n  }\n\n  return {\n    range: toRange(textEdit.range),\n    text: textEdit.newText\n  };\n}\n\nvar CompletionAdapter =\n/** @class */\nfunction () {\n  function CompletionAdapter(_worker) {\n    this._worker = _worker;\n  }\n\n  Object.defineProperty(CompletionAdapter.prototype, \"triggerCharacters\", {\n    get: function get() {\n      return [' ', ':'];\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  CompletionAdapter.prototype.provideCompletionItems = function (model, position, context, token) {\n    var resource = model.uri;\n    return this._worker(resource).then(function (worker) {\n      return worker.doComplete(resource.toString(), fromPosition(position));\n    }).then(function (info) {\n      if (!info) {\n        return;\n      }\n\n      var wordInfo = model.getWordUntilPosition(position);\n      var wordRange = new Range(position.lineNumber, wordInfo.startColumn, position.lineNumber, wordInfo.endColumn);\n      var items = info.items.map(function (entry) {\n        var item = {\n          label: entry.label,\n          insertText: entry.insertText || entry.label,\n          sortText: entry.sortText,\n          filterText: entry.filterText,\n          documentation: entry.documentation,\n          detail: entry.detail,\n          range: wordRange,\n          kind: toCompletionItemKind(entry.kind)\n        };\n\n        if (entry.textEdit) {\n          item.range = toRange(entry.textEdit.range);\n          item.insertText = entry.textEdit.newText;\n        }\n\n        if (entry.additionalTextEdits) {\n          item.additionalTextEdits = entry.additionalTextEdits.map(toTextEdit);\n        }\n\n        if (entry.insertTextFormat === ls.InsertTextFormat.Snippet) {\n          item.insertTextRules = monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet;\n        }\n\n        return item;\n      });\n      return {\n        isIncomplete: info.isIncomplete,\n        suggestions: items\n      };\n    });\n  };\n\n  return CompletionAdapter;\n}();\n\nexport { CompletionAdapter };\n\nfunction isMarkupContent(thing) {\n  return thing && typeof thing === 'object' && typeof thing.kind === 'string';\n}\n\nfunction toMarkdownString(entry) {\n  if (typeof entry === 'string') {\n    return {\n      value: entry\n    };\n  }\n\n  if (isMarkupContent(entry)) {\n    if (entry.kind === 'plaintext') {\n      return {\n        value: entry.value.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, '\\\\$&')\n      };\n    }\n\n    return {\n      value: entry.value\n    };\n  }\n\n  return {\n    value: '```' + entry.language + '\\n' + entry.value + '\\n```\\n'\n  };\n}\n\nfunction toMarkedStringArray(contents) {\n  if (!contents) {\n    return void 0;\n  }\n\n  if (Array.isArray(contents)) {\n    return contents.map(toMarkdownString);\n  }\n\n  return [toMarkdownString(contents)];\n} // --- hover ------\n\n\nvar HoverAdapter =\n/** @class */\nfunction () {\n  function HoverAdapter(_worker) {\n    this._worker = _worker;\n  }\n\n  HoverAdapter.prototype.provideHover = function (model, position, token) {\n    var resource = model.uri;\n    return this._worker(resource).then(function (worker) {\n      return worker.doHover(resource.toString(), fromPosition(position));\n    }).then(function (info) {\n      if (!info) {\n        return;\n      }\n\n      return {\n        range: toRange(info.range),\n        contents: toMarkedStringArray(info.contents)\n      };\n    });\n  };\n\n  return HoverAdapter;\n}();\n\nexport { HoverAdapter }; // --- definition ------\n\nfunction toLocation(location) {\n  return {\n    uri: Uri.parse(location.uri),\n    range: toRange(location.range)\n  };\n} // --- document symbols ------\n\n\nfunction toSymbolKind(kind) {\n  var mKind = monaco.languages.SymbolKind;\n\n  switch (kind) {\n    case ls.SymbolKind.File:\n      return mKind.Array;\n\n    case ls.SymbolKind.Module:\n      return mKind.Module;\n\n    case ls.SymbolKind.Namespace:\n      return mKind.Namespace;\n\n    case ls.SymbolKind.Package:\n      return mKind.Package;\n\n    case ls.SymbolKind.Class:\n      return mKind.Class;\n\n    case ls.SymbolKind.Method:\n      return mKind.Method;\n\n    case ls.SymbolKind.Property:\n      return mKind.Property;\n\n    case ls.SymbolKind.Field:\n      return mKind.Field;\n\n    case ls.SymbolKind.Constructor:\n      return mKind.Constructor;\n\n    case ls.SymbolKind.Enum:\n      return mKind.Enum;\n\n    case ls.SymbolKind.Interface:\n      return mKind.Interface;\n\n    case ls.SymbolKind.Function:\n      return mKind.Function;\n\n    case ls.SymbolKind.Variable:\n      return mKind.Variable;\n\n    case ls.SymbolKind.Constant:\n      return mKind.Constant;\n\n    case ls.SymbolKind.String:\n      return mKind.String;\n\n    case ls.SymbolKind.Number:\n      return mKind.Number;\n\n    case ls.SymbolKind.Boolean:\n      return mKind.Boolean;\n\n    case ls.SymbolKind.Array:\n      return mKind.Array;\n  }\n\n  return mKind.Function;\n}\n\nvar DocumentSymbolAdapter =\n/** @class */\nfunction () {\n  function DocumentSymbolAdapter(_worker) {\n    this._worker = _worker;\n  }\n\n  DocumentSymbolAdapter.prototype.provideDocumentSymbols = function (model, token) {\n    var resource = model.uri;\n    return this._worker(resource).then(function (worker) {\n      return worker.findDocumentSymbols(resource.toString());\n    }).then(function (items) {\n      if (!items) {\n        return;\n      }\n\n      return items.map(function (item) {\n        return {\n          name: item.name,\n          detail: '',\n          containerName: item.containerName,\n          kind: toSymbolKind(item.kind),\n          range: toRange(item.location.range),\n          selectionRange: toRange(item.location.range),\n          tags: []\n        };\n      });\n    });\n  };\n\n  return DocumentSymbolAdapter;\n}();\n\nexport { DocumentSymbolAdapter };\n\nfunction fromFormattingOptions(options) {\n  return {\n    tabSize: options.tabSize,\n    insertSpaces: options.insertSpaces\n  };\n}\n\nvar DocumentFormattingEditProvider =\n/** @class */\nfunction () {\n  function DocumentFormattingEditProvider(_worker) {\n    this._worker = _worker;\n  }\n\n  DocumentFormattingEditProvider.prototype.provideDocumentFormattingEdits = function (model, options, token) {\n    var resource = model.uri;\n    return this._worker(resource).then(function (worker) {\n      return worker.format(resource.toString(), null, fromFormattingOptions(options)).then(function (edits) {\n        if (!edits || edits.length === 0) {\n          return;\n        }\n\n        return edits.map(toTextEdit);\n      });\n    });\n  };\n\n  return DocumentFormattingEditProvider;\n}();\n\nexport { DocumentFormattingEditProvider };\n\nvar DocumentRangeFormattingEditProvider =\n/** @class */\nfunction () {\n  function DocumentRangeFormattingEditProvider(_worker) {\n    this._worker = _worker;\n  }\n\n  DocumentRangeFormattingEditProvider.prototype.provideDocumentRangeFormattingEdits = function (model, range, options, token) {\n    var resource = model.uri;\n    return this._worker(resource).then(function (worker) {\n      return worker.format(resource.toString(), fromRange(range), fromFormattingOptions(options)).then(function (edits) {\n        if (!edits || edits.length === 0) {\n          return;\n        }\n\n        return edits.map(toTextEdit);\n      });\n    });\n  };\n\n  return DocumentRangeFormattingEditProvider;\n}();\n\nexport { DocumentRangeFormattingEditProvider };\n\nvar DocumentColorAdapter =\n/** @class */\nfunction () {\n  function DocumentColorAdapter(_worker) {\n    this._worker = _worker;\n  }\n\n  DocumentColorAdapter.prototype.provideDocumentColors = function (model, token) {\n    var resource = model.uri;\n    return this._worker(resource).then(function (worker) {\n      return worker.findDocumentColors(resource.toString());\n    }).then(function (infos) {\n      if (!infos) {\n        return;\n      }\n\n      return infos.map(function (item) {\n        return {\n          color: item.color,\n          range: toRange(item.range)\n        };\n      });\n    });\n  };\n\n  DocumentColorAdapter.prototype.provideColorPresentations = function (model, info, token) {\n    var resource = model.uri;\n    return this._worker(resource).then(function (worker) {\n      return worker.getColorPresentations(resource.toString(), info.color, fromRange(info.range));\n    }).then(function (presentations) {\n      if (!presentations) {\n        return;\n      }\n\n      return presentations.map(function (presentation) {\n        var item = {\n          label: presentation.label\n        };\n\n        if (presentation.textEdit) {\n          item.textEdit = toTextEdit(presentation.textEdit);\n        }\n\n        if (presentation.additionalTextEdits) {\n          item.additionalTextEdits = presentation.additionalTextEdits.map(toTextEdit);\n        }\n\n        return item;\n      });\n    });\n  };\n\n  return DocumentColorAdapter;\n}();\n\nexport { DocumentColorAdapter };\n\nvar FoldingRangeAdapter =\n/** @class */\nfunction () {\n  function FoldingRangeAdapter(_worker) {\n    this._worker = _worker;\n  }\n\n  FoldingRangeAdapter.prototype.provideFoldingRanges = function (model, context, token) {\n    var resource = model.uri;\n    return this._worker(resource).then(function (worker) {\n      return worker.provideFoldingRanges(resource.toString(), context);\n    }).then(function (ranges) {\n      if (!ranges) {\n        return;\n      }\n\n      return ranges.map(function (range) {\n        var result = {\n          start: range.startLine + 1,\n          end: range.endLine + 1\n        };\n\n        if (typeof range.kind !== 'undefined') {\n          result.kind = toFoldingRangeKind(range.kind);\n        }\n\n        return result;\n      });\n    });\n  };\n\n  return FoldingRangeAdapter;\n}();\n\nexport { FoldingRangeAdapter };\n\nfunction toFoldingRangeKind(kind) {\n  switch (kind) {\n    case ls.FoldingRangeKind.Comment:\n      return monaco.languages.FoldingRangeKind.Comment;\n\n    case ls.FoldingRangeKind.Imports:\n      return monaco.languages.FoldingRangeKind.Imports;\n\n    case ls.FoldingRangeKind.Region:\n      return monaco.languages.FoldingRangeKind.Region;\n  }\n\n  return void 0;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\n\nexport function createScanner(text, ignoreTrivia) {\n  if (ignoreTrivia === void 0) {\n    ignoreTrivia = false;\n  }\n\n  var pos = 0,\n      len = text.length,\n      value = '',\n      tokenOffset = 0,\n      token = 16\n  /* Unknown */\n  ,\n      lineNumber = 0,\n      lineStartOffset = 0,\n      tokenLineStartOffset = 0,\n      prevTokenLineStartOffset = 0,\n      scanError = 0\n  /* None */\n  ;\n\n  function scanHexDigits(count, exact) {\n    var digits = 0;\n    var value = 0;\n\n    while (digits < count || !exact) {\n      var ch = text.charCodeAt(pos);\n\n      if (ch >= 48\n      /* _0 */\n      && ch <= 57\n      /* _9 */\n      ) {\n          value = value * 16 + ch - 48\n          /* _0 */\n          ;\n        } else if (ch >= 65\n      /* A */\n      && ch <= 70\n      /* F */\n      ) {\n          value = value * 16 + ch - 65\n          /* A */\n          + 10;\n        } else if (ch >= 97\n      /* a */\n      && ch <= 102\n      /* f */\n      ) {\n          value = value * 16 + ch - 97\n          /* a */\n          + 10;\n        } else {\n        break;\n      }\n\n      pos++;\n      digits++;\n    }\n\n    if (digits < count) {\n      value = -1;\n    }\n\n    return value;\n  }\n\n  function setPosition(newPosition) {\n    pos = newPosition;\n    value = '';\n    tokenOffset = 0;\n    token = 16\n    /* Unknown */\n    ;\n    scanError = 0\n    /* None */\n    ;\n  }\n\n  function scanNumber() {\n    var start = pos;\n\n    if (text.charCodeAt(pos) === 48\n    /* _0 */\n    ) {\n        pos++;\n      } else {\n      pos++;\n\n      while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n        pos++;\n      }\n    }\n\n    if (pos < text.length && text.charCodeAt(pos) === 46\n    /* dot */\n    ) {\n        pos++;\n\n        if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n          pos++;\n\n          while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n            pos++;\n          }\n        } else {\n          scanError = 3\n          /* UnexpectedEndOfNumber */\n          ;\n          return text.substring(start, pos);\n        }\n      }\n\n    var end = pos;\n\n    if (pos < text.length && (text.charCodeAt(pos) === 69\n    /* E */\n    || text.charCodeAt(pos) === 101\n    /* e */\n    )) {\n      pos++;\n\n      if (pos < text.length && text.charCodeAt(pos) === 43\n      /* plus */\n      || text.charCodeAt(pos) === 45\n      /* minus */\n      ) {\n          pos++;\n        }\n\n      if (pos < text.length && isDigit(text.charCodeAt(pos))) {\n        pos++;\n\n        while (pos < text.length && isDigit(text.charCodeAt(pos))) {\n          pos++;\n        }\n\n        end = pos;\n      } else {\n        scanError = 3\n        /* UnexpectedEndOfNumber */\n        ;\n      }\n    }\n\n    return text.substring(start, end);\n  }\n\n  function scanString() {\n    var result = '',\n        start = pos;\n\n    while (true) {\n      if (pos >= len) {\n        result += text.substring(start, pos);\n        scanError = 2\n        /* UnexpectedEndOfString */\n        ;\n        break;\n      }\n\n      var ch = text.charCodeAt(pos);\n\n      if (ch === 34\n      /* doubleQuote */\n      ) {\n          result += text.substring(start, pos);\n          pos++;\n          break;\n        }\n\n      if (ch === 92\n      /* backslash */\n      ) {\n          result += text.substring(start, pos);\n          pos++;\n\n          if (pos >= len) {\n            scanError = 2\n            /* UnexpectedEndOfString */\n            ;\n            break;\n          }\n\n          ch = text.charCodeAt(pos++);\n\n          switch (ch) {\n            case 34\n            /* doubleQuote */\n            :\n              result += '\\\"';\n              break;\n\n            case 92\n            /* backslash */\n            :\n              result += '\\\\';\n              break;\n\n            case 47\n            /* slash */\n            :\n              result += '/';\n              break;\n\n            case 98\n            /* b */\n            :\n              result += '\\b';\n              break;\n\n            case 102\n            /* f */\n            :\n              result += '\\f';\n              break;\n\n            case 110\n            /* n */\n            :\n              result += '\\n';\n              break;\n\n            case 114\n            /* r */\n            :\n              result += '\\r';\n              break;\n\n            case 116\n            /* t */\n            :\n              result += '\\t';\n              break;\n\n            case 117\n            /* u */\n            :\n              var ch_1 = scanHexDigits(4, true);\n\n              if (ch_1 >= 0) {\n                result += String.fromCharCode(ch_1);\n              } else {\n                scanError = 4\n                /* InvalidUnicode */\n                ;\n              }\n\n              break;\n\n            default:\n              scanError = 5\n              /* InvalidEscapeCharacter */\n              ;\n          }\n\n          start = pos;\n          continue;\n        }\n\n      if (ch >= 0 && ch <= 0x1f) {\n        if (isLineBreak(ch)) {\n          result += text.substring(start, pos);\n          scanError = 2\n          /* UnexpectedEndOfString */\n          ;\n          break;\n        } else {\n          scanError = 6\n          /* InvalidCharacter */\n          ; // mark as error but continue with string\n        }\n      }\n\n      pos++;\n    }\n\n    return result;\n  }\n\n  function scanNext() {\n    value = '';\n    scanError = 0\n    /* None */\n    ;\n    tokenOffset = pos;\n    lineStartOffset = lineNumber;\n    prevTokenLineStartOffset = tokenLineStartOffset;\n\n    if (pos >= len) {\n      // at the end\n      tokenOffset = len;\n      return token = 17\n      /* EOF */\n      ;\n    }\n\n    var code = text.charCodeAt(pos); // trivia: whitespace\n\n    if (isWhiteSpace(code)) {\n      do {\n        pos++;\n        value += String.fromCharCode(code);\n        code = text.charCodeAt(pos);\n      } while (isWhiteSpace(code));\n\n      return token = 15\n      /* Trivia */\n      ;\n    } // trivia: newlines\n\n\n    if (isLineBreak(code)) {\n      pos++;\n      value += String.fromCharCode(code);\n\n      if (code === 13\n      /* carriageReturn */\n      && text.charCodeAt(pos) === 10\n      /* lineFeed */\n      ) {\n          pos++;\n          value += '\\n';\n        }\n\n      lineNumber++;\n      tokenLineStartOffset = pos;\n      return token = 14\n      /* LineBreakTrivia */\n      ;\n    }\n\n    switch (code) {\n      // tokens: []{}:,\n      case 123\n      /* openBrace */\n      :\n        pos++;\n        return token = 1\n        /* OpenBraceToken */\n        ;\n\n      case 125\n      /* closeBrace */\n      :\n        pos++;\n        return token = 2\n        /* CloseBraceToken */\n        ;\n\n      case 91\n      /* openBracket */\n      :\n        pos++;\n        return token = 3\n        /* OpenBracketToken */\n        ;\n\n      case 93\n      /* closeBracket */\n      :\n        pos++;\n        return token = 4\n        /* CloseBracketToken */\n        ;\n\n      case 58\n      /* colon */\n      :\n        pos++;\n        return token = 6\n        /* ColonToken */\n        ;\n\n      case 44\n      /* comma */\n      :\n        pos++;\n        return token = 5\n        /* CommaToken */\n        ;\n      // strings\n\n      case 34\n      /* doubleQuote */\n      :\n        pos++;\n        value = scanString();\n        return token = 10\n        /* StringLiteral */\n        ;\n      // comments\n\n      case 47\n      /* slash */\n      :\n        var start = pos - 1; // Single-line comment\n\n        if (text.charCodeAt(pos + 1) === 47\n        /* slash */\n        ) {\n            pos += 2;\n\n            while (pos < len) {\n              if (isLineBreak(text.charCodeAt(pos))) {\n                break;\n              }\n\n              pos++;\n            }\n\n            value = text.substring(start, pos);\n            return token = 12\n            /* LineCommentTrivia */\n            ;\n          } // Multi-line comment\n\n\n        if (text.charCodeAt(pos + 1) === 42\n        /* asterisk */\n        ) {\n            pos += 2;\n            var safeLength = len - 1; // For lookahead.\n\n            var commentClosed = false;\n\n            while (pos < safeLength) {\n              var ch = text.charCodeAt(pos);\n\n              if (ch === 42\n              /* asterisk */\n              && text.charCodeAt(pos + 1) === 47\n              /* slash */\n              ) {\n                  pos += 2;\n                  commentClosed = true;\n                  break;\n                }\n\n              pos++;\n\n              if (isLineBreak(ch)) {\n                if (ch === 13\n                /* carriageReturn */\n                && text.charCodeAt(pos) === 10\n                /* lineFeed */\n                ) {\n                    pos++;\n                  }\n\n                lineNumber++;\n                tokenLineStartOffset = pos;\n              }\n            }\n\n            if (!commentClosed) {\n              pos++;\n              scanError = 1\n              /* UnexpectedEndOfComment */\n              ;\n            }\n\n            value = text.substring(start, pos);\n            return token = 13\n            /* BlockCommentTrivia */\n            ;\n          } // just a single slash\n\n\n        value += String.fromCharCode(code);\n        pos++;\n        return token = 16\n        /* Unknown */\n        ;\n      // numbers\n\n      case 45\n      /* minus */\n      :\n        value += String.fromCharCode(code);\n        pos++;\n\n        if (pos === len || !isDigit(text.charCodeAt(pos))) {\n          return token = 16\n          /* Unknown */\n          ;\n        }\n\n      // found a minus, followed by a number so\n      // we fall through to proceed with scanning\n      // numbers\n\n      case 48\n      /* _0 */\n      :\n      case 49\n      /* _1 */\n      :\n      case 50\n      /* _2 */\n      :\n      case 51\n      /* _3 */\n      :\n      case 52\n      /* _4 */\n      :\n      case 53\n      /* _5 */\n      :\n      case 54\n      /* _6 */\n      :\n      case 55\n      /* _7 */\n      :\n      case 56\n      /* _8 */\n      :\n      case 57\n      /* _9 */\n      :\n        value += scanNumber();\n        return token = 11\n        /* NumericLiteral */\n        ;\n      // literals and unknown symbols\n\n      default:\n        // is a literal? Read the full word.\n        while (pos < len && isUnknownContentCharacter(code)) {\n          pos++;\n          code = text.charCodeAt(pos);\n        }\n\n        if (tokenOffset !== pos) {\n          value = text.substring(tokenOffset, pos); // keywords: true, false, null\n\n          switch (value) {\n            case 'true':\n              return token = 8\n              /* TrueKeyword */\n              ;\n\n            case 'false':\n              return token = 9\n              /* FalseKeyword */\n              ;\n\n            case 'null':\n              return token = 7\n              /* NullKeyword */\n              ;\n          }\n\n          return token = 16\n          /* Unknown */\n          ;\n        } // some\n\n\n        value += String.fromCharCode(code);\n        pos++;\n        return token = 16\n        /* Unknown */\n        ;\n    }\n  }\n\n  function isUnknownContentCharacter(code) {\n    if (isWhiteSpace(code) || isLineBreak(code)) {\n      return false;\n    }\n\n    switch (code) {\n      case 125\n      /* closeBrace */\n      :\n      case 93\n      /* closeBracket */\n      :\n      case 123\n      /* openBrace */\n      :\n      case 91\n      /* openBracket */\n      :\n      case 34\n      /* doubleQuote */\n      :\n      case 58\n      /* colon */\n      :\n      case 44\n      /* comma */\n      :\n      case 47\n      /* slash */\n      :\n        return false;\n    }\n\n    return true;\n  }\n\n  function scanNextNonTrivia() {\n    var result;\n\n    do {\n      result = scanNext();\n    } while (result >= 12\n    /* LineCommentTrivia */\n    && result <= 15\n    /* Trivia */\n    );\n\n    return result;\n  }\n\n  return {\n    setPosition: setPosition,\n    getPosition: function getPosition() {\n      return pos;\n    },\n    scan: ignoreTrivia ? scanNextNonTrivia : scanNext,\n    getToken: function getToken() {\n      return token;\n    },\n    getTokenValue: function getTokenValue() {\n      return value;\n    },\n    getTokenOffset: function getTokenOffset() {\n      return tokenOffset;\n    },\n    getTokenLength: function getTokenLength() {\n      return pos - tokenOffset;\n    },\n    getTokenStartLine: function getTokenStartLine() {\n      return lineStartOffset;\n    },\n    getTokenStartCharacter: function getTokenStartCharacter() {\n      return tokenOffset - prevTokenLineStartOffset;\n    },\n    getTokenError: function getTokenError() {\n      return scanError;\n    }\n  };\n}\n\nfunction isWhiteSpace(ch) {\n  return ch === 32\n  /* space */\n  || ch === 9\n  /* tab */\n  || ch === 11\n  /* verticalTab */\n  || ch === 12\n  /* formFeed */\n  || ch === 160\n  /* nonBreakingSpace */\n  || ch === 5760\n  /* ogham */\n  || ch >= 8192\n  /* enQuad */\n  && ch <= 8203\n  /* zeroWidthSpace */\n  || ch === 8239\n  /* narrowNoBreakSpace */\n  || ch === 8287\n  /* mathematicalSpace */\n  || ch === 12288\n  /* ideographicSpace */\n  || ch === 65279\n  /* byteOrderMark */\n  ;\n}\n\nfunction isLineBreak(ch) {\n  return ch === 10\n  /* lineFeed */\n  || ch === 13\n  /* carriageReturn */\n  || ch === 8232\n  /* lineSeparator */\n  || ch === 8233\n  /* paragraphSeparator */\n  ;\n}\n\nfunction isDigit(ch) {\n  return ch >= 48\n  /* _0 */\n  && ch <= 57\n  /* _9 */\n  ;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport { createScanner } from './scanner.js';\nexport function format(documentText, range, options) {\n  var initialIndentLevel;\n  var formatText;\n  var formatTextStart;\n  var rangeStart;\n  var rangeEnd;\n\n  if (range) {\n    rangeStart = range.offset;\n    rangeEnd = rangeStart + range.length;\n    formatTextStart = rangeStart;\n\n    while (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) {\n      formatTextStart--;\n    }\n\n    var endOffset = rangeEnd;\n\n    while (endOffset < documentText.length && !isEOL(documentText, endOffset)) {\n      endOffset++;\n    }\n\n    formatText = documentText.substring(formatTextStart, endOffset);\n    initialIndentLevel = computeIndentLevel(formatText, options);\n  } else {\n    formatText = documentText;\n    initialIndentLevel = 0;\n    formatTextStart = 0;\n    rangeStart = 0;\n    rangeEnd = documentText.length;\n  }\n\n  var eol = getEOL(options, documentText);\n  var lineBreak = false;\n  var indentLevel = 0;\n  var indentValue;\n\n  if (options.insertSpaces) {\n    indentValue = repeat(' ', options.tabSize || 4);\n  } else {\n    indentValue = '\\t';\n  }\n\n  var scanner = createScanner(formatText, false);\n  var hasError = false;\n\n  function newLineAndIndent() {\n    return eol + repeat(indentValue, initialIndentLevel + indentLevel);\n  }\n\n  function scanNext() {\n    var token = scanner.scan();\n    lineBreak = false;\n\n    while (token === 15\n    /* Trivia */\n    || token === 14\n    /* LineBreakTrivia */\n    ) {\n      lineBreak = lineBreak || token === 14\n      /* LineBreakTrivia */\n      ;\n      token = scanner.scan();\n    }\n\n    hasError = token === 16\n    /* Unknown */\n    || scanner.getTokenError() !== 0\n    /* None */\n    ;\n    return token;\n  }\n\n  var editOperations = [];\n\n  function addEdit(text, startOffset, endOffset) {\n    if (!hasError && startOffset < rangeEnd && endOffset > rangeStart && documentText.substring(startOffset, endOffset) !== text) {\n      editOperations.push({\n        offset: startOffset,\n        length: endOffset - startOffset,\n        content: text\n      });\n    }\n  }\n\n  var firstToken = scanNext();\n\n  if (firstToken !== 17\n  /* EOF */\n  ) {\n      var firstTokenStart = scanner.getTokenOffset() + formatTextStart;\n      var initialIndent = repeat(indentValue, initialIndentLevel);\n      addEdit(initialIndent, formatTextStart, firstTokenStart);\n    }\n\n  while (firstToken !== 17\n  /* EOF */\n  ) {\n    var firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n    var secondToken = scanNext();\n    var replaceContent = '';\n\n    while (!lineBreak && (secondToken === 12\n    /* LineCommentTrivia */\n    || secondToken === 13\n    /* BlockCommentTrivia */\n    )) {\n      // comments on the same line: keep them on the same line, but ignore them otherwise\n      var commentTokenStart = scanner.getTokenOffset() + formatTextStart;\n      addEdit(' ', firstTokenEnd, commentTokenStart);\n      firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;\n      replaceContent = secondToken === 12\n      /* LineCommentTrivia */\n      ? newLineAndIndent() : '';\n      secondToken = scanNext();\n    }\n\n    if (secondToken === 2\n    /* CloseBraceToken */\n    ) {\n        if (firstToken !== 1\n        /* OpenBraceToken */\n        ) {\n            indentLevel--;\n            replaceContent = newLineAndIndent();\n          }\n      } else if (secondToken === 4\n    /* CloseBracketToken */\n    ) {\n        if (firstToken !== 3\n        /* OpenBracketToken */\n        ) {\n            indentLevel--;\n            replaceContent = newLineAndIndent();\n          }\n      } else {\n      switch (firstToken) {\n        case 3\n        /* OpenBracketToken */\n        :\n        case 1\n        /* OpenBraceToken */\n        :\n          indentLevel++;\n          replaceContent = newLineAndIndent();\n          break;\n\n        case 5\n        /* CommaToken */\n        :\n        case 12\n        /* LineCommentTrivia */\n        :\n          replaceContent = newLineAndIndent();\n          break;\n\n        case 13\n        /* BlockCommentTrivia */\n        :\n          if (lineBreak) {\n            replaceContent = newLineAndIndent();\n          } else {\n            // symbol following comment on the same line: keep on same line, separate with ' '\n            replaceContent = ' ';\n          }\n\n          break;\n\n        case 6\n        /* ColonToken */\n        :\n          replaceContent = ' ';\n          break;\n\n        case 10\n        /* StringLiteral */\n        :\n          if (secondToken === 6\n          /* ColonToken */\n          ) {\n              replaceContent = '';\n              break;\n            }\n\n        // fall through\n\n        case 7\n        /* NullKeyword */\n        :\n        case 8\n        /* TrueKeyword */\n        :\n        case 9\n        /* FalseKeyword */\n        :\n        case 11\n        /* NumericLiteral */\n        :\n        case 2\n        /* CloseBraceToken */\n        :\n        case 4\n        /* CloseBracketToken */\n        :\n          if (secondToken === 12\n          /* LineCommentTrivia */\n          || secondToken === 13\n          /* BlockCommentTrivia */\n          ) {\n              replaceContent = ' ';\n            } else if (secondToken !== 5\n          /* CommaToken */\n          && secondToken !== 17\n          /* EOF */\n          ) {\n              hasError = true;\n            }\n\n          break;\n\n        case 16\n        /* Unknown */\n        :\n          hasError = true;\n          break;\n      }\n\n      if (lineBreak && (secondToken === 12\n      /* LineCommentTrivia */\n      || secondToken === 13\n      /* BlockCommentTrivia */\n      )) {\n        replaceContent = newLineAndIndent();\n      }\n    }\n\n    var secondTokenStart = scanner.getTokenOffset() + formatTextStart;\n    addEdit(replaceContent, firstTokenEnd, secondTokenStart);\n    firstToken = secondToken;\n  }\n\n  return editOperations;\n}\n\nfunction repeat(s, count) {\n  var result = '';\n\n  for (var i = 0; i < count; i++) {\n    result += s;\n  }\n\n  return result;\n}\n\nfunction computeIndentLevel(content, options) {\n  var i = 0;\n  var nChars = 0;\n  var tabSize = options.tabSize || 4;\n\n  while (i < content.length) {\n    var ch = content.charAt(i);\n\n    if (ch === ' ') {\n      nChars++;\n    } else if (ch === '\\t') {\n      nChars += tabSize;\n    } else {\n      break;\n    }\n\n    i++;\n  }\n\n  return Math.floor(nChars / tabSize);\n}\n\nfunction getEOL(options, text) {\n  for (var i = 0; i < text.length; i++) {\n    var ch = text.charAt(i);\n\n    if (ch === '\\r') {\n      if (i + 1 < text.length && text.charAt(i + 1) === '\\n') {\n        return '\\r\\n';\n      }\n\n      return '\\r';\n    } else if (ch === '\\n') {\n      return '\\n';\n    }\n  }\n\n  return options && options.eol || '\\n';\n}\n\nexport function isEOL(text, offset) {\n  return '\\r\\n'.indexOf(text.charAt(offset)) !== -1;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport { createScanner } from './scanner.js';\nvar ParseOptions;\n\n(function (ParseOptions) {\n  ParseOptions.DEFAULT = {\n    allowTrailingComma: false\n  };\n})(ParseOptions || (ParseOptions = {}));\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\n\n\nexport function getLocation(text, position) {\n  var segments = []; // strings or numbers\n\n  var earlyReturnException = new Object();\n  var previousNode = void 0;\n  var previousNodeInst = {\n    value: {},\n    offset: 0,\n    length: 0,\n    type: 'object',\n    parent: void 0\n  };\n  var isAtPropertyKey = false;\n\n  function setPreviousNode(value, offset, length, type) {\n    previousNodeInst.value = value;\n    previousNodeInst.offset = offset;\n    previousNodeInst.length = length;\n    previousNodeInst.type = type;\n    previousNodeInst.colonOffset = void 0;\n    previousNode = previousNodeInst;\n  }\n\n  try {\n    visit(text, {\n      onObjectBegin: function onObjectBegin(offset, length) {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n\n        previousNode = void 0;\n        isAtPropertyKey = position > offset;\n        segments.push(''); // push a placeholder (will be replaced)\n      },\n      onObjectProperty: function onObjectProperty(name, offset, length) {\n        if (position < offset) {\n          throw earlyReturnException;\n        }\n\n        setPreviousNode(name, offset, length, 'property');\n        segments[segments.length - 1] = name;\n\n        if (position <= offset + length) {\n          throw earlyReturnException;\n        }\n      },\n      onObjectEnd: function onObjectEnd(offset, length) {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n\n        previousNode = void 0;\n        segments.pop();\n      },\n      onArrayBegin: function onArrayBegin(offset, length) {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n\n        previousNode = void 0;\n        segments.push(0);\n      },\n      onArrayEnd: function onArrayEnd(offset, length) {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n\n        previousNode = void 0;\n        segments.pop();\n      },\n      onLiteralValue: function onLiteralValue(value, offset, length) {\n        if (position < offset) {\n          throw earlyReturnException;\n        }\n\n        setPreviousNode(value, offset, length, getLiteralNodeType(value));\n\n        if (position <= offset + length) {\n          throw earlyReturnException;\n        }\n      },\n      onSeparator: function onSeparator(sep, offset, length) {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n\n        if (sep === ':' && previousNode && previousNode.type === 'property') {\n          previousNode.colonOffset = offset;\n          isAtPropertyKey = false;\n          previousNode = void 0;\n        } else if (sep === ',') {\n          var last = segments[segments.length - 1];\n\n          if (typeof last === 'number') {\n            segments[segments.length - 1] = last + 1;\n          } else {\n            isAtPropertyKey = true;\n            segments[segments.length - 1] = '';\n          }\n\n          previousNode = void 0;\n        }\n      }\n    });\n  } catch (e) {\n    if (e !== earlyReturnException) {\n      throw e;\n    }\n  }\n\n  return {\n    path: segments,\n    previousNode: previousNode,\n    isAtPropertyKey: isAtPropertyKey,\n    matches: function matches(pattern) {\n      var k = 0;\n\n      for (var i = 0; k < pattern.length && i < segments.length; i++) {\n        if (pattern[k] === segments[i] || pattern[k] === '*') {\n          k++;\n        } else if (pattern[k] !== '**') {\n          return false;\n        }\n      }\n\n      return k === pattern.length;\n    }\n  };\n}\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\n\nexport function parse(text, errors, options) {\n  if (errors === void 0) {\n    errors = [];\n  }\n\n  if (options === void 0) {\n    options = ParseOptions.DEFAULT;\n  }\n\n  var currentProperty = null;\n  var currentParent = [];\n  var previousParents = [];\n\n  function onValue(value) {\n    if (Array.isArray(currentParent)) {\n      currentParent.push(value);\n    } else if (currentProperty) {\n      currentParent[currentProperty] = value;\n    }\n  }\n\n  var visitor = {\n    onObjectBegin: function onObjectBegin() {\n      var object = {};\n      onValue(object);\n      previousParents.push(currentParent);\n      currentParent = object;\n      currentProperty = null;\n    },\n    onObjectProperty: function onObjectProperty(name) {\n      currentProperty = name;\n    },\n    onObjectEnd: function onObjectEnd() {\n      currentParent = previousParents.pop();\n    },\n    onArrayBegin: function onArrayBegin() {\n      var array = [];\n      onValue(array);\n      previousParents.push(currentParent);\n      currentParent = array;\n      currentProperty = null;\n    },\n    onArrayEnd: function onArrayEnd() {\n      currentParent = previousParents.pop();\n    },\n    onLiteralValue: onValue,\n    onError: function onError(error, offset, length) {\n      errors.push({\n        error: error,\n        offset: offset,\n        length: length\n      });\n    }\n  };\n  visit(text, visitor, options);\n  return currentParent[0];\n}\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\n\nexport function parseTree(text, errors, options) {\n  if (errors === void 0) {\n    errors = [];\n  }\n\n  if (options === void 0) {\n    options = ParseOptions.DEFAULT;\n  }\n\n  var currentParent = {\n    type: 'array',\n    offset: -1,\n    length: -1,\n    children: [],\n    parent: void 0\n  }; // artificial root\n\n  function ensurePropertyComplete(endOffset) {\n    if (currentParent.type === 'property') {\n      currentParent.length = endOffset - currentParent.offset;\n      currentParent = currentParent.parent;\n    }\n  }\n\n  function onValue(valueNode) {\n    currentParent.children.push(valueNode);\n    return valueNode;\n  }\n\n  var visitor = {\n    onObjectBegin: function onObjectBegin(offset) {\n      currentParent = onValue({\n        type: 'object',\n        offset: offset,\n        length: -1,\n        parent: currentParent,\n        children: []\n      });\n    },\n    onObjectProperty: function onObjectProperty(name, offset, length) {\n      currentParent = onValue({\n        type: 'property',\n        offset: offset,\n        length: -1,\n        parent: currentParent,\n        children: []\n      });\n      currentParent.children.push({\n        type: 'string',\n        value: name,\n        offset: offset,\n        length: length,\n        parent: currentParent\n      });\n    },\n    onObjectEnd: function onObjectEnd(offset, length) {\n      currentParent.length = offset + length - currentParent.offset;\n      currentParent = currentParent.parent;\n      ensurePropertyComplete(offset + length);\n    },\n    onArrayBegin: function onArrayBegin(offset, length) {\n      currentParent = onValue({\n        type: 'array',\n        offset: offset,\n        length: -1,\n        parent: currentParent,\n        children: []\n      });\n    },\n    onArrayEnd: function onArrayEnd(offset, length) {\n      currentParent.length = offset + length - currentParent.offset;\n      currentParent = currentParent.parent;\n      ensurePropertyComplete(offset + length);\n    },\n    onLiteralValue: function onLiteralValue(value, offset, length) {\n      onValue({\n        type: getLiteralNodeType(value),\n        offset: offset,\n        length: length,\n        parent: currentParent,\n        value: value\n      });\n      ensurePropertyComplete(offset + length);\n    },\n    onSeparator: function onSeparator(sep, offset, length) {\n      if (currentParent.type === 'property') {\n        if (sep === ':') {\n          currentParent.colonOffset = offset;\n        } else if (sep === ',') {\n          ensurePropertyComplete(offset);\n        }\n      }\n    },\n    onError: function onError(error, offset, length) {\n      errors.push({\n        error: error,\n        offset: offset,\n        length: length\n      });\n    }\n  };\n  visit(text, visitor, options);\n  var result = currentParent.children[0];\n\n  if (result) {\n    delete result.parent;\n  }\n\n  return result;\n}\n/**\n * Finds the node at the given path in a JSON DOM.\n */\n\nexport function findNodeAtLocation(root, path) {\n  if (!root) {\n    return void 0;\n  }\n\n  var node = root;\n\n  for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {\n    var segment = path_1[_i];\n\n    if (typeof segment === 'string') {\n      if (node.type !== 'object' || !Array.isArray(node.children)) {\n        return void 0;\n      }\n\n      var found = false;\n\n      for (var _a = 0, _b = node.children; _a < _b.length; _a++) {\n        var propertyNode = _b[_a];\n\n        if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {\n          node = propertyNode.children[1];\n          found = true;\n          break;\n        }\n      }\n\n      if (!found) {\n        return void 0;\n      }\n    } else {\n      var index = segment;\n\n      if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {\n        return void 0;\n      }\n\n      node = node.children[index];\n    }\n  }\n\n  return node;\n}\n/**\n * Gets the JSON path of the given JSON DOM node\n */\n\nexport function getNodePath(node) {\n  if (!node.parent || !node.parent.children) {\n    return [];\n  }\n\n  var path = getNodePath(node.parent);\n\n  if (node.parent.type === 'property') {\n    var key = node.parent.children[0].value;\n    path.push(key);\n  } else if (node.parent.type === 'array') {\n    var index = node.parent.children.indexOf(node);\n\n    if (index !== -1) {\n      path.push(index);\n    }\n  }\n\n  return path;\n}\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\n\nexport function getNodeValue(node) {\n  switch (node.type) {\n    case 'array':\n      return node.children.map(getNodeValue);\n\n    case 'object':\n      var obj = Object.create(null);\n\n      for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n        var prop = _a[_i];\n        var valueNode = prop.children[1];\n\n        if (valueNode) {\n          obj[prop.children[0].value] = getNodeValue(valueNode);\n        }\n      }\n\n      return obj;\n\n    case 'null':\n    case 'string':\n    case 'number':\n    case 'boolean':\n      return node.value;\n\n    default:\n      return void 0;\n  }\n}\nexport function contains(node, offset, includeRightBound) {\n  if (includeRightBound === void 0) {\n    includeRightBound = false;\n  }\n\n  return offset >= node.offset && offset < node.offset + node.length || includeRightBound && offset === node.offset + node.length;\n}\n/**\n * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\n\nexport function findNodeAtOffset(node, offset, includeRightBound) {\n  if (includeRightBound === void 0) {\n    includeRightBound = false;\n  }\n\n  if (contains(node, offset, includeRightBound)) {\n    var children = node.children;\n\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length && children[i].offset <= offset; i++) {\n        var item = findNodeAtOffset(children[i], offset, includeRightBound);\n\n        if (item) {\n          return item;\n        }\n      }\n    }\n\n    return node;\n  }\n\n  return void 0;\n}\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\n\nexport function visit(text, visitor, options) {\n  if (options === void 0) {\n    options = ParseOptions.DEFAULT;\n  }\n\n  var _scanner = createScanner(text, false);\n\n  function toNoArgVisit(visitFunction) {\n    return visitFunction ? function () {\n      return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());\n    } : function () {\n      return true;\n    };\n  }\n\n  function toOneArgVisit(visitFunction) {\n    return visitFunction ? function (arg) {\n      return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());\n    } : function () {\n      return true;\n    };\n  }\n\n  var onObjectBegin = toNoArgVisit(visitor.onObjectBegin),\n      onObjectProperty = toOneArgVisit(visitor.onObjectProperty),\n      onObjectEnd = toNoArgVisit(visitor.onObjectEnd),\n      onArrayBegin = toNoArgVisit(visitor.onArrayBegin),\n      onArrayEnd = toNoArgVisit(visitor.onArrayEnd),\n      onLiteralValue = toOneArgVisit(visitor.onLiteralValue),\n      onSeparator = toOneArgVisit(visitor.onSeparator),\n      onComment = toNoArgVisit(visitor.onComment),\n      onError = toOneArgVisit(visitor.onError);\n  var disallowComments = options && options.disallowComments;\n  var allowTrailingComma = options && options.allowTrailingComma;\n\n  function scanNext() {\n    while (true) {\n      var token = _scanner.scan();\n\n      switch (_scanner.getTokenError()) {\n        case 4\n        /* InvalidUnicode */\n        :\n          handleError(14\n          /* InvalidUnicode */\n          );\n          break;\n\n        case 5\n        /* InvalidEscapeCharacter */\n        :\n          handleError(15\n          /* InvalidEscapeCharacter */\n          );\n          break;\n\n        case 3\n        /* UnexpectedEndOfNumber */\n        :\n          handleError(13\n          /* UnexpectedEndOfNumber */\n          );\n          break;\n\n        case 1\n        /* UnexpectedEndOfComment */\n        :\n          if (!disallowComments) {\n            handleError(11\n            /* UnexpectedEndOfComment */\n            );\n          }\n\n          break;\n\n        case 2\n        /* UnexpectedEndOfString */\n        :\n          handleError(12\n          /* UnexpectedEndOfString */\n          );\n          break;\n\n        case 6\n        /* InvalidCharacter */\n        :\n          handleError(16\n          /* InvalidCharacter */\n          );\n          break;\n      }\n\n      switch (token) {\n        case 12\n        /* LineCommentTrivia */\n        :\n        case 13\n        /* BlockCommentTrivia */\n        :\n          if (disallowComments) {\n            handleError(10\n            /* InvalidCommentToken */\n            );\n          } else {\n            onComment();\n          }\n\n          break;\n\n        case 16\n        /* Unknown */\n        :\n          handleError(1\n          /* InvalidSymbol */\n          );\n          break;\n\n        case 15\n        /* Trivia */\n        :\n        case 14\n        /* LineBreakTrivia */\n        :\n          break;\n\n        default:\n          return token;\n      }\n    }\n  }\n\n  function handleError(error, skipUntilAfter, skipUntil) {\n    if (skipUntilAfter === void 0) {\n      skipUntilAfter = [];\n    }\n\n    if (skipUntil === void 0) {\n      skipUntil = [];\n    }\n\n    onError(error);\n\n    if (skipUntilAfter.length + skipUntil.length > 0) {\n      var token = _scanner.getToken();\n\n      while (token !== 17\n      /* EOF */\n      ) {\n        if (skipUntilAfter.indexOf(token) !== -1) {\n          scanNext();\n          break;\n        } else if (skipUntil.indexOf(token) !== -1) {\n          break;\n        }\n\n        token = scanNext();\n      }\n    }\n  }\n\n  function parseString(isValue) {\n    var value = _scanner.getTokenValue();\n\n    if (isValue) {\n      onLiteralValue(value);\n    } else {\n      onObjectProperty(value);\n    }\n\n    scanNext();\n    return true;\n  }\n\n  function parseLiteral() {\n    switch (_scanner.getToken()) {\n      case 11\n      /* NumericLiteral */\n      :\n        var value = 0;\n\n        try {\n          value = JSON.parse(_scanner.getTokenValue());\n\n          if (typeof value !== 'number') {\n            handleError(2\n            /* InvalidNumberFormat */\n            );\n            value = 0;\n          }\n        } catch (e) {\n          handleError(2\n          /* InvalidNumberFormat */\n          );\n        }\n\n        onLiteralValue(value);\n        break;\n\n      case 7\n      /* NullKeyword */\n      :\n        onLiteralValue(null);\n        break;\n\n      case 8\n      /* TrueKeyword */\n      :\n        onLiteralValue(true);\n        break;\n\n      case 9\n      /* FalseKeyword */\n      :\n        onLiteralValue(false);\n        break;\n\n      default:\n        return false;\n    }\n\n    scanNext();\n    return true;\n  }\n\n  function parseProperty() {\n    if (_scanner.getToken() !== 10\n    /* StringLiteral */\n    ) {\n        handleError(3\n        /* PropertyNameExpected */\n        , [], [2\n        /* CloseBraceToken */\n        , 5\n        /* CommaToken */\n        ]);\n        return false;\n      }\n\n    parseString(false);\n\n    if (_scanner.getToken() === 6\n    /* ColonToken */\n    ) {\n        onSeparator(':');\n        scanNext(); // consume colon\n\n        if (!parseValue()) {\n          handleError(4\n          /* ValueExpected */\n          , [], [2\n          /* CloseBraceToken */\n          , 5\n          /* CommaToken */\n          ]);\n        }\n      } else {\n      handleError(5\n      /* ColonExpected */\n      , [], [2\n      /* CloseBraceToken */\n      , 5\n      /* CommaToken */\n      ]);\n    }\n\n    return true;\n  }\n\n  function parseObject() {\n    onObjectBegin();\n    scanNext(); // consume open brace\n\n    var needsComma = false;\n\n    while (_scanner.getToken() !== 2\n    /* CloseBraceToken */\n    && _scanner.getToken() !== 17\n    /* EOF */\n    ) {\n      if (_scanner.getToken() === 5\n      /* CommaToken */\n      ) {\n          if (!needsComma) {\n            handleError(4\n            /* ValueExpected */\n            , [], []);\n          }\n\n          onSeparator(',');\n          scanNext(); // consume comma\n\n          if (_scanner.getToken() === 2\n          /* CloseBraceToken */\n          && allowTrailingComma) {\n            break;\n          }\n        } else if (needsComma) {\n        handleError(6\n        /* CommaExpected */\n        , [], []);\n      }\n\n      if (!parseProperty()) {\n        handleError(4\n        /* ValueExpected */\n        , [], [2\n        /* CloseBraceToken */\n        , 5\n        /* CommaToken */\n        ]);\n      }\n\n      needsComma = true;\n    }\n\n    onObjectEnd();\n\n    if (_scanner.getToken() !== 2\n    /* CloseBraceToken */\n    ) {\n        handleError(7\n        /* CloseBraceExpected */\n        , [2\n        /* CloseBraceToken */\n        ], []);\n      } else {\n      scanNext(); // consume close brace\n    }\n\n    return true;\n  }\n\n  function parseArray() {\n    onArrayBegin();\n    scanNext(); // consume open bracket\n\n    var needsComma = false;\n\n    while (_scanner.getToken() !== 4\n    /* CloseBracketToken */\n    && _scanner.getToken() !== 17\n    /* EOF */\n    ) {\n      if (_scanner.getToken() === 5\n      /* CommaToken */\n      ) {\n          if (!needsComma) {\n            handleError(4\n            /* ValueExpected */\n            , [], []);\n          }\n\n          onSeparator(',');\n          scanNext(); // consume comma\n\n          if (_scanner.getToken() === 4\n          /* CloseBracketToken */\n          && allowTrailingComma) {\n            break;\n          }\n        } else if (needsComma) {\n        handleError(6\n        /* CommaExpected */\n        , [], []);\n      }\n\n      if (!parseValue()) {\n        handleError(4\n        /* ValueExpected */\n        , [], [4\n        /* CloseBracketToken */\n        , 5\n        /* CommaToken */\n        ]);\n      }\n\n      needsComma = true;\n    }\n\n    onArrayEnd();\n\n    if (_scanner.getToken() !== 4\n    /* CloseBracketToken */\n    ) {\n        handleError(8\n        /* CloseBracketExpected */\n        , [4\n        /* CloseBracketToken */\n        ], []);\n      } else {\n      scanNext(); // consume close bracket\n    }\n\n    return true;\n  }\n\n  function parseValue() {\n    switch (_scanner.getToken()) {\n      case 3\n      /* OpenBracketToken */\n      :\n        return parseArray();\n\n      case 1\n      /* OpenBraceToken */\n      :\n        return parseObject();\n\n      case 10\n      /* StringLiteral */\n      :\n        return parseString(true);\n\n      default:\n        return parseLiteral();\n    }\n  }\n\n  scanNext();\n\n  if (_scanner.getToken() === 17\n  /* EOF */\n  ) {\n      return true;\n    }\n\n  if (!parseValue()) {\n    handleError(4\n    /* ValueExpected */\n    , [], []);\n    return false;\n  }\n\n  if (_scanner.getToken() !== 17\n  /* EOF */\n  ) {\n      handleError(9\n      /* EndOfFileExpected */\n      , [], []);\n    }\n\n  return true;\n}\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\n\nexport function stripComments(text, replaceCh) {\n  var _scanner = createScanner(text),\n      parts = [],\n      kind,\n      offset = 0,\n      pos;\n\n  do {\n    pos = _scanner.getPosition();\n    kind = _scanner.scan();\n\n    switch (kind) {\n      case 12\n      /* LineCommentTrivia */\n      :\n      case 13\n      /* BlockCommentTrivia */\n      :\n      case 17\n      /* EOF */\n      :\n        if (offset !== pos) {\n          parts.push(text.substring(offset, pos));\n        }\n\n        if (replaceCh !== void 0) {\n          parts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n        }\n\n        offset = _scanner.getPosition();\n        break;\n    }\n  } while (kind !== 17\n  /* EOF */\n  );\n\n  return parts.join('');\n}\n\nfunction getLiteralNodeType(value) {\n  switch (typeof value) {\n    case 'boolean':\n      return 'boolean';\n\n    case 'number':\n      return 'number';\n\n    case 'string':\n      return 'string';\n\n    default:\n      return 'null';\n  }\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport { format, isEOL } from './format.js';\nimport { parseTree, findNodeAtLocation } from './parser.js';\nexport function removeProperty(text, path, formattingOptions) {\n  return setProperty(text, path, void 0, formattingOptions);\n}\nexport function setProperty(text, originalPath, value, formattingOptions, getInsertionIndex) {\n  var _a;\n\n  var path = originalPath.slice();\n  var errors = [];\n  var root = parseTree(text, errors);\n  var parent = void 0;\n  var lastSegment = void 0;\n\n  while (path.length > 0) {\n    lastSegment = path.pop();\n    parent = findNodeAtLocation(root, path);\n\n    if (parent === void 0 && value !== void 0) {\n      if (typeof lastSegment === 'string') {\n        value = (_a = {}, _a[lastSegment] = value, _a);\n      } else {\n        value = [value];\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (!parent) {\n    // empty document\n    if (value === void 0) {\n      // delete\n      throw new Error('Can not delete in empty document');\n    }\n\n    return withFormatting(text, {\n      offset: root ? root.offset : 0,\n      length: root ? root.length : 0,\n      content: JSON.stringify(value)\n    }, formattingOptions);\n  } else if (parent.type === 'object' && typeof lastSegment === 'string' && Array.isArray(parent.children)) {\n    var existing = findNodeAtLocation(parent, [lastSegment]);\n\n    if (existing !== void 0) {\n      if (value === void 0) {\n        // delete\n        if (!existing.parent) {\n          throw new Error('Malformed AST');\n        }\n\n        var propertyIndex = parent.children.indexOf(existing.parent);\n        var removeBegin = void 0;\n        var removeEnd = existing.parent.offset + existing.parent.length;\n\n        if (propertyIndex > 0) {\n          // remove the comma of the previous node\n          var previous = parent.children[propertyIndex - 1];\n          removeBegin = previous.offset + previous.length;\n        } else {\n          removeBegin = parent.offset + 1;\n\n          if (parent.children.length > 1) {\n            // remove the comma of the next node\n            var next = parent.children[1];\n            removeEnd = next.offset;\n          }\n        }\n\n        return withFormatting(text, {\n          offset: removeBegin,\n          length: removeEnd - removeBegin,\n          content: ''\n        }, formattingOptions);\n      } else {\n        // set value of existing property\n        return withFormatting(text, {\n          offset: existing.offset,\n          length: existing.length,\n          content: JSON.stringify(value)\n        }, formattingOptions);\n      }\n    } else {\n      if (value === void 0) {\n        // delete\n        return []; // property does not exist, nothing to do\n      }\n\n      var newProperty = JSON.stringify(lastSegment) + \": \" + JSON.stringify(value);\n      var index = getInsertionIndex ? getInsertionIndex(parent.children.map(function (p) {\n        return p.children[0].value;\n      })) : parent.children.length;\n      var edit = void 0;\n\n      if (index > 0) {\n        var previous = parent.children[index - 1];\n        edit = {\n          offset: previous.offset + previous.length,\n          length: 0,\n          content: ',' + newProperty\n        };\n      } else if (parent.children.length === 0) {\n        edit = {\n          offset: parent.offset + 1,\n          length: 0,\n          content: newProperty\n        };\n      } else {\n        edit = {\n          offset: parent.offset + 1,\n          length: 0,\n          content: newProperty + ','\n        };\n      }\n\n      return withFormatting(text, edit, formattingOptions);\n    }\n  } else if (parent.type === 'array' && typeof lastSegment === 'number' && Array.isArray(parent.children)) {\n    var insertIndex = lastSegment;\n\n    if (insertIndex === -1) {\n      // Insert\n      var newProperty = \"\" + JSON.stringify(value);\n      var edit = void 0;\n\n      if (parent.children.length === 0) {\n        edit = {\n          offset: parent.offset + 1,\n          length: 0,\n          content: newProperty\n        };\n      } else {\n        var previous = parent.children[parent.children.length - 1];\n        edit = {\n          offset: previous.offset + previous.length,\n          length: 0,\n          content: ',' + newProperty\n        };\n      }\n\n      return withFormatting(text, edit, formattingOptions);\n    } else {\n      if (value === void 0 && parent.children.length >= 0) {\n        //Removal\n        var removalIndex = lastSegment;\n        var toRemove = parent.children[removalIndex];\n        var edit = void 0;\n\n        if (parent.children.length === 1) {\n          // only item\n          edit = {\n            offset: parent.offset + 1,\n            length: parent.length - 2,\n            content: ''\n          };\n        } else if (parent.children.length - 1 === removalIndex) {\n          // last item\n          var previous = parent.children[removalIndex - 1];\n          var offset = previous.offset + previous.length;\n          var parentEndOffset = parent.offset + parent.length;\n          edit = {\n            offset: offset,\n            length: parentEndOffset - 2 - offset,\n            content: ''\n          };\n        } else {\n          edit = {\n            offset: toRemove.offset,\n            length: parent.children[removalIndex + 1].offset - toRemove.offset,\n            content: ''\n          };\n        }\n\n        return withFormatting(text, edit, formattingOptions);\n      } else {\n        throw new Error('Array modification not supported yet');\n      }\n    }\n  } else {\n    throw new Error(\"Can not add \" + (typeof lastSegment !== 'number' ? 'index' : 'property') + \" to parent of type \" + parent.type);\n  }\n}\n\nfunction withFormatting(text, edit, formattingOptions) {\n  // apply the edit\n  var newText = applyEdit(text, edit); // format the new text\n\n  var begin = edit.offset;\n  var end = edit.offset + edit.content.length;\n\n  if (edit.length === 0 || edit.content.length === 0) {\n    // insert or remove\n    while (begin > 0 && !isEOL(newText, begin - 1)) {\n      begin--;\n    }\n\n    while (end < newText.length && !isEOL(newText, end)) {\n      end++;\n    }\n  }\n\n  var edits = format(newText, {\n    offset: begin,\n    length: end - begin\n  }, formattingOptions); // apply the formatting edits and track the begin and end offsets of the changes\n\n  for (var i = edits.length - 1; i >= 0; i--) {\n    var edit_1 = edits[i];\n    newText = applyEdit(newText, edit_1);\n    begin = Math.min(begin, edit_1.offset);\n    end = Math.max(end, edit_1.offset + edit_1.length);\n    end += edit_1.content.length - edit_1.length;\n  } // create a single edit with all changes\n\n\n  var editLength = text.length - (newText.length - end) - begin;\n  return [{\n    offset: begin,\n    length: editLength,\n    content: newText.substring(begin, end)\n  }];\n}\n\nexport function applyEdit(text, edit) {\n  return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);\n}\nexport function isWS(text, offset) {\n  return '\\r\\n \\t'.indexOf(text.charAt(offset)) !== -1;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport * as formatter from './impl/format.js';\nimport * as edit from './impl/edit.js';\nimport * as scanner from './impl/scanner.js';\nimport * as parser from './impl/parser.js';\n/**\n * Creates a JSON scanner on the given text.\n * If ignoreTrivia is set, whitespaces or comments are ignored.\n */\n\nexport var createScanner = scanner.createScanner;\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\n\nexport var getLocation = parser.getLocation;\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore, always check the errors list to find out if the input was valid.\n */\n\nexport var parse = parser.parse;\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\n\nexport var parseTree = parser.parseTree;\n/**\n * Finds the node at the given path in a JSON DOM.\n */\n\nexport var findNodeAtLocation = parser.findNodeAtLocation;\n/**\n * Finds the innermost node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\n\nexport var findNodeAtOffset = parser.findNodeAtOffset;\n/**\n * Gets the JSON path of the given JSON DOM node\n */\n\nexport var getNodePath = parser.getNodePath;\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\n\nexport var getNodeValue = parser.getNodeValue;\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\n\nexport var visit = parser.visit;\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\n\nexport var stripComments = parser.stripComments;\nexport function printParseErrorCode(code) {\n  switch (code) {\n    case 1\n    /* InvalidSymbol */\n    :\n      return 'InvalidSymbol';\n\n    case 2\n    /* InvalidNumberFormat */\n    :\n      return 'InvalidNumberFormat';\n\n    case 3\n    /* PropertyNameExpected */\n    :\n      return 'PropertyNameExpected';\n\n    case 4\n    /* ValueExpected */\n    :\n      return 'ValueExpected';\n\n    case 5\n    /* ColonExpected */\n    :\n      return 'ColonExpected';\n\n    case 6\n    /* CommaExpected */\n    :\n      return 'CommaExpected';\n\n    case 7\n    /* CloseBraceExpected */\n    :\n      return 'CloseBraceExpected';\n\n    case 8\n    /* CloseBracketExpected */\n    :\n      return 'CloseBracketExpected';\n\n    case 9\n    /* EndOfFileExpected */\n    :\n      return 'EndOfFileExpected';\n\n    case 10\n    /* InvalidCommentToken */\n    :\n      return 'InvalidCommentToken';\n\n    case 11\n    /* UnexpectedEndOfComment */\n    :\n      return 'UnexpectedEndOfComment';\n\n    case 12\n    /* UnexpectedEndOfString */\n    :\n      return 'UnexpectedEndOfString';\n\n    case 13\n    /* UnexpectedEndOfNumber */\n    :\n      return 'UnexpectedEndOfNumber';\n\n    case 14\n    /* InvalidUnicode */\n    :\n      return 'InvalidUnicode';\n\n    case 15\n    /* InvalidEscapeCharacter */\n    :\n      return 'InvalidEscapeCharacter';\n\n    case 16\n    /* InvalidCharacter */\n    :\n      return 'InvalidCharacter';\n  }\n\n  return '<unknown ParseErrorCode>';\n}\n/**\n * Computes the edits needed to format a JSON document.\n *\n * @param documentText The input text\n * @param range The range to format or `undefined` to format the full content\n * @param options The formatting options\n * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n * text in the original document. However, multiple edits can have\n * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n * To apply edits to an input, you can use `applyEdits`.\n */\n\nexport function format(documentText, range, options) {\n  return formatter.format(documentText, range, options);\n}\n/**\n * Computes the edits needed to modify a value in the JSON document.\n *\n * @param documentText The input text\n * @param path The path of the value to change. The path represents either to the document root, a property or an array item.\n * If the path points to an non-existing property or item, it will be created.\n * @param value The new value for the specified property or item. If the value is undefined,\n * the property or item will be removed.\n * @param options Options\n * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or\n * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of\n * text in the original document. However, multiple edits can have\n * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.\n * To apply edits to an input, you can use `applyEdits`.\n */\n\nexport function modify(text, path, value, options) {\n  return edit.setProperty(text, path, value, options.formattingOptions, options.getInsertionIndex);\n}\n/**\n * Applies edits to a input string.\n */\n\nexport function applyEdits(text, edits) {\n  for (var i = edits.length - 1; i >= 0; i--) {\n    text = edit.applyEdit(text, edits[i]);\n  }\n\n  return text;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport * as json from './_deps/jsonc-parser/main.js';\nexport function createTokenizationSupport(supportComments) {\n  return {\n    getInitialState: function getInitialState() {\n      return new JSONState(null, null, false);\n    },\n    tokenize: function tokenize(line, state, offsetDelta, stopAtOffset) {\n      return _tokenize(supportComments, line, state, offsetDelta, stopAtOffset);\n    }\n  };\n}\nexport var TOKEN_DELIM_OBJECT = 'delimiter.bracket.json';\nexport var TOKEN_DELIM_ARRAY = 'delimiter.array.json';\nexport var TOKEN_DELIM_COLON = 'delimiter.colon.json';\nexport var TOKEN_DELIM_COMMA = 'delimiter.comma.json';\nexport var TOKEN_VALUE_BOOLEAN = 'keyword.json';\nexport var TOKEN_VALUE_NULL = 'keyword.json';\nexport var TOKEN_VALUE_STRING = 'string.value.json';\nexport var TOKEN_VALUE_NUMBER = 'number.json';\nexport var TOKEN_PROPERTY_NAME = 'string.key.json';\nexport var TOKEN_COMMENT_BLOCK = 'comment.block.json';\nexport var TOKEN_COMMENT_LINE = 'comment.line.json';\n\nvar JSONState =\n/** @class */\nfunction () {\n  function JSONState(state, scanError, lastWasColon) {\n    this._state = state;\n    this.scanError = scanError;\n    this.lastWasColon = lastWasColon;\n  }\n\n  JSONState.prototype.clone = function () {\n    return new JSONState(this._state, this.scanError, this.lastWasColon);\n  };\n\n  JSONState.prototype.equals = function (other) {\n    if (other === this) {\n      return true;\n    }\n\n    if (!other || !(other instanceof JSONState)) {\n      return false;\n    }\n\n    return this.scanError === other.scanError && this.lastWasColon === other.lastWasColon;\n  };\n\n  JSONState.prototype.getStateData = function () {\n    return this._state;\n  };\n\n  JSONState.prototype.setStateData = function (state) {\n    this._state = state;\n  };\n\n  return JSONState;\n}();\n\nfunction _tokenize(comments, line, state, offsetDelta, stopAtOffset) {\n  if (offsetDelta === void 0) {\n    offsetDelta = 0;\n  } // handle multiline strings and block comments\n\n\n  var numberOfInsertedCharacters = 0,\n      adjustOffset = false;\n\n  switch (state.scanError) {\n    case 2\n    /* UnexpectedEndOfString */\n    :\n      line = '\"' + line;\n      numberOfInsertedCharacters = 1;\n      break;\n\n    case 1\n    /* UnexpectedEndOfComment */\n    :\n      line = '/*' + line;\n      numberOfInsertedCharacters = 2;\n      break;\n  }\n\n  var scanner = json.createScanner(line),\n      kind,\n      ret,\n      lastWasColon = state.lastWasColon;\n  ret = {\n    tokens: [],\n    endState: state.clone()\n  };\n\n  while (true) {\n    var offset = offsetDelta + scanner.getPosition(),\n        type = '';\n    kind = scanner.scan();\n\n    if (kind === 17\n    /* EOF */\n    ) {\n        break;\n      } // Check that the scanner has advanced\n\n\n    if (offset === offsetDelta + scanner.getPosition()) {\n      throw new Error('Scanner did not advance, next 3 characters are: ' + line.substr(scanner.getPosition(), 3));\n    } // In case we inserted /* or \" character, we need to\n    // adjust the offset of all tokens (except the first)\n\n\n    if (adjustOffset) {\n      offset -= numberOfInsertedCharacters;\n    }\n\n    adjustOffset = numberOfInsertedCharacters > 0; // brackets and type\n\n    switch (kind) {\n      case 1\n      /* OpenBraceToken */\n      :\n        type = TOKEN_DELIM_OBJECT;\n        lastWasColon = false;\n        break;\n\n      case 2\n      /* CloseBraceToken */\n      :\n        type = TOKEN_DELIM_OBJECT;\n        lastWasColon = false;\n        break;\n\n      case 3\n      /* OpenBracketToken */\n      :\n        type = TOKEN_DELIM_ARRAY;\n        lastWasColon = false;\n        break;\n\n      case 4\n      /* CloseBracketToken */\n      :\n        type = TOKEN_DELIM_ARRAY;\n        lastWasColon = false;\n        break;\n\n      case 6\n      /* ColonToken */\n      :\n        type = TOKEN_DELIM_COLON;\n        lastWasColon = true;\n        break;\n\n      case 5\n      /* CommaToken */\n      :\n        type = TOKEN_DELIM_COMMA;\n        lastWasColon = false;\n        break;\n\n      case 8\n      /* TrueKeyword */\n      :\n      case 9\n      /* FalseKeyword */\n      :\n        type = TOKEN_VALUE_BOOLEAN;\n        lastWasColon = false;\n        break;\n\n      case 7\n      /* NullKeyword */\n      :\n        type = TOKEN_VALUE_NULL;\n        lastWasColon = false;\n        break;\n\n      case 10\n      /* StringLiteral */\n      :\n        type = lastWasColon ? TOKEN_VALUE_STRING : TOKEN_PROPERTY_NAME;\n        lastWasColon = false;\n        break;\n\n      case 11\n      /* NumericLiteral */\n      :\n        type = TOKEN_VALUE_NUMBER;\n        lastWasColon = false;\n        break;\n    } // comments, iff enabled\n\n\n    if (comments) {\n      switch (kind) {\n        case 12\n        /* LineCommentTrivia */\n        :\n          type = TOKEN_COMMENT_LINE;\n          break;\n\n        case 13\n        /* BlockCommentTrivia */\n        :\n          type = TOKEN_COMMENT_BLOCK;\n          break;\n      }\n    }\n\n    ret.endState = new JSONState(state.getStateData(), scanner.getTokenError(), lastWasColon);\n    ret.tokens.push({\n      startIndex: offset,\n      scopes: type\n    });\n  }\n\n  return ret;\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport { WorkerManager } from './workerManager.js';\nimport * as languageFeatures from './languageFeatures.js';\nimport { createTokenizationSupport } from './tokenization.js';\nexport function setupMode(defaults) {\n  var disposables = [];\n  var providers = [];\n  var client = new WorkerManager(defaults);\n  disposables.push(client);\n\n  var worker = function worker() {\n    var uris = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      uris[_i] = arguments[_i];\n    }\n\n    return client.getLanguageServiceWorker.apply(client, uris);\n  };\n\n  function registerProviders() {\n    var languageId = defaults.languageId,\n        modeConfiguration = defaults.modeConfiguration;\n    disposeAll(providers);\n\n    if (modeConfiguration.documentFormattingEdits) {\n      providers.push(monaco.languages.registerDocumentFormattingEditProvider(languageId, new languageFeatures.DocumentFormattingEditProvider(worker)));\n    }\n\n    if (modeConfiguration.documentRangeFormattingEdits) {\n      providers.push(monaco.languages.registerDocumentRangeFormattingEditProvider(languageId, new languageFeatures.DocumentRangeFormattingEditProvider(worker)));\n    }\n\n    if (modeConfiguration.completionItems) {\n      providers.push(monaco.languages.registerCompletionItemProvider(languageId, new languageFeatures.CompletionAdapter(worker)));\n    }\n\n    if (modeConfiguration.hovers) {\n      providers.push(monaco.languages.registerHoverProvider(languageId, new languageFeatures.HoverAdapter(worker)));\n    }\n\n    if (modeConfiguration.documentSymbols) {\n      providers.push(monaco.languages.registerDocumentSymbolProvider(languageId, new languageFeatures.DocumentSymbolAdapter(worker)));\n    }\n\n    if (modeConfiguration.tokens) {\n      providers.push(monaco.languages.setTokensProvider(languageId, createTokenizationSupport(true)));\n    }\n\n    if (modeConfiguration.colors) {\n      providers.push(monaco.languages.registerColorProvider(languageId, new languageFeatures.DocumentColorAdapter(worker)));\n    }\n\n    if (modeConfiguration.foldingRanges) {\n      providers.push(monaco.languages.registerFoldingRangeProvider(languageId, new languageFeatures.FoldingRangeAdapter(worker)));\n    }\n\n    if (modeConfiguration.diagnostics) {\n      providers.push(new languageFeatures.DiagnosticsAdapter(languageId, worker, defaults));\n    }\n  }\n\n  registerProviders();\n  disposables.push(monaco.languages.setLanguageConfiguration(defaults.languageId, richEditConfiguration));\n  var modeConfiguration = defaults.modeConfiguration;\n  defaults.onDidChange(function (newDefaults) {\n    if (newDefaults.modeConfiguration !== modeConfiguration) {\n      modeConfiguration = newDefaults.modeConfiguration;\n      registerProviders();\n    }\n  });\n  disposables.push(asDisposable(providers));\n  return asDisposable(disposables);\n}\n\nfunction asDisposable(disposables) {\n  return {\n    dispose: function dispose() {\n      return disposeAll(disposables);\n    }\n  };\n}\n\nfunction disposeAll(disposables) {\n  while (disposables.length) {\n    disposables.pop().dispose();\n  }\n}\n\nvar richEditConfiguration = {\n  wordPattern: /(-?\\d*\\.\\d\\w*)|([^\\[\\{\\]\\}\\:\\\"\\,\\s]+)/g,\n  comments: {\n    lineComment: '//',\n    blockComment: ['/*', '*/']\n  },\n  brackets: [['{', '}'], ['[', ']']],\n  autoClosingPairs: [{\n    open: '{',\n    close: '}',\n    notIn: ['string']\n  }, {\n    open: '[',\n    close: ']',\n    notIn: ['string']\n  }, {\n    open: '\"',\n    close: '\"',\n    notIn: ['string']\n  }]\n};"],"sourceRoot":""}